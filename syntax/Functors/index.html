<!DOCTYPE html><head><meta charset="UTF-8"><title>Functor system | Ferret</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="1054433d-b479-4550-821f-40a0632c8dc5" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="47c60e19-8fe8-479a-a31b-88d9adea4974" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5d2cf0f3-5b79-4221-a1ed-4a3413a1b495" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d4634258-4c53-488f-8d13-73d65838b4cb" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="0108607d-dde4-4ec7-ba2b-ea4643e4d386" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="bda4bd2b-aa90-4b2a-85c8-b52b396a3c91"><i class="material-icons">menu</i></a><ul class="sidenav" id="bda4bd2b-aa90-4b2a-85c8-b52b396a3c91"><li><a href="#!" class="dropdown-trigger" data-target="968f5220-58ea-4fcb-8f8d-9e18bf873d01" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="0a5438bf-c02b-442d-894a-96ba8191541b" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ca218581-376a-49c3-9f13-555774d2588e" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6d625419-30d7-484f-bf88-d8ffc93a318e" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="607b4212-7cbe-4237-85c0-dbd0ec193b13" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="1054433d-b479-4550-821f-40a0632c8dc5"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="47c60e19-8fe8-479a-a31b-88d9adea4974"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="5d2cf0f3-5b79-4221-a1ed-4a3413a1b495"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="d4634258-4c53-488f-8d13-73d65838b4cb"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="0108607d-dde4-4ec7-ba2b-ea4643e4d386"><li><a href="../index.html">Complete syntax</a></li><li><a href="../ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="968f5220-58ea-4fcb-8f8d-9e18bf873d01"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="0a5438bf-c02b-442d-894a-96ba8191541b"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="ca218581-376a-49c3-9f13-555774d2588e"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="6d625419-30d7-484f-bf88-d8ffc93a318e"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="607b4212-7cbe-4237-85c0-dbd0ec193b13"><li><a href="../index.html">Complete syntax</a></li><li><a href="../ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="bf57f40e-3ec9-43ec-be70-d41f369c29e7" data-section-level="1" data-section-text="Functor system"><h1 id="functor-system">Functor system</h1><p>Functors are an abstraction, existing as a base class, that is available to several systems in MOOSE:</p><ul class="browser-default"><li><p><a href="../Variables/index.html">Variables</a> </p></li><li><p><a href="../AuxVariables/index.html">Auxiliary variables</a> </p></li><li><p><a href="../FunctorMaterials/index.html">Functor material properties</a> </p></li><li><p><a href="../Functions/index.html">Functions</a> </p></li><li><p><a href="../Postprocessors/index.html">Post-processors</a></p></li></ul><p>All functors can be called using the same interfaces. This enables considerable code re-use. For example, instead of having a kernel for each type of coupled forcing term, like <a href="../../source/kernels/CoupledForce.html">CoupledForce / ADCoupledForce</a>, <a href="../../source/kernels/BodyForce.html">BodyForce</a>, <a href="../../source/kernels/MatCoupledForce.html">MatCoupledForce</a>, <a href="../../source/kernels/ADMatCoupledForce.html">ADMatCoupledForce</a>, we could just have a single object <code>FunctorForce</code> and have the force term be a functor.</p><p><code>Functions</code> provide a good analogy to <code>Functors</code>. Both <code>Functions</code> and <code>Functors</code> are evaluated on-the-fly at a location in space and time, but for <code>Functors</code>, the space arguments can be an element, a point in an element, a face of an element, and so on. The time arguments represent the state of the functor : current, previous value (whether in time or iteration), or value before that previous one.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>Using post-processors</div><div class="card-content"><div class="moose-alert-content"><p>Note that when using post-processors, instead of being evaluated on-the-fly at a point in space and time, the most recently computed value is used, in accordance with the <code>execute_on</code> for the post-processor.</p></div></div></div><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>If a Functor is reported as missing by the simulation, you may use the <code>Debug/</code><a href="#61183640-f47a-4318-9cf9-47a9b791972e" class="moose-modal-link modal-trigger">&quot;show_functors&quot;</a> parameter to get more information about which functors were created and requested.</p></div></div></div><section id="fea3201e-3748-4c27-87ae-f008baf4ba80" data-section-level="2" data-section-text="Developing with functors"><h2 id="developing-with-functors">Developing with functors</h2><p>Functors are stored on the <code>SubProblem</code>, a derived class of <a href="../Problem/index.html">Problems</a> that is used for solving nonlinear systems. As such, classes do not need to have memory ownership of functors, they may simply store a reference or a pointer.</p><p>In the header of a class using a <code>Functor</code> <code>_functor</code> you will have:</p><pre class="moose-pre"><code class="language-text">
const Moose::Functor&lt;T&gt; &amp; _functor
</code></pre><p>to store a reference to <code>_functor</code>. <code>T</code> is the return type of the functor. For a variable, it should be <code>ADReal</code>. For a vector variable, it would be <code>ADRealVectorValue</code>. If the object using the functor is not leveraging AD, it may be <code>Real</code> or <code>RealVectorValue</code>.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>With regards to <a href="../../automatic_differentiation/index.html">automatic differentiation</a>, <code>Functors</code> are automatically converted between <code>AD</code> and <code>non-AD</code> types when retrieved. When you retrieve a <code>Functor</code>, you must only think about whether you need <code>AD</code> in the consuming object. When you create a <code>Functor</code> (for example, a <a href="../FunctorMaterials/index.html">functor material property</a>) it&#x27;s best practice to always use the <code>AD</code> return type so as to never discard some derivatives.</p></div></div></div><p>In the constructor of the same class, you will have:</p><pre class="moose-pre"><code class="language-text">
CLASSNAME::CLASSNAME(const InputParameters &amp; parameters) :
  ...
  _functor(getFunctor&lt;T&gt;(&quot;&lt;functor_parameter_name&gt;&quot;)),
  ...
</code></pre><p>where <code>CLASSNAME</code> is the name of the class, <code>T</code> is still the required return type of the functor, and <code>&lt;functor_parameter_name&gt;</code> is the name of the parameter used for providing the functor in the input.</p><section id="d2056041-41a6-43c0-b523-ec58c8d2d963" data-section-level="3" data-section-text="Evaluating functors"><h3 id="using-functors">Evaluating functors</h3><p>Functors are evaluated on-the-fly. E.g. they can be viewed as functions of the current location in space (and time). Functors provide several overloads of the <code>operator()</code> method for different &quot;geometric quantities&quot;. One example of a &quot;geometric quantity&quot; is based around an element, e.g. for an <code>FVElementalKernel</code>, the value of a functor material property in a cell-averaged sense can be obtained by the syntax</p><ul class="browser-default"><li><p><code>_foo(makeElemArg(_current_elem), determineState())</code></p></li></ul><p>where here <code>_foo</code> is a functor data member of the kernel, <code>makeElemArg</code> is a helper routine for creating a functor element-based spatial argument, and <code>determineState()</code> is a helper routine for determining the correct time state to evaluate at, e.g. the current time for an implicit kernel and the old time for an explicit kernel.</p></section><section id="c7732d69-6ff8-4d03-91ff-887ba179485b" data-section-level="3" data-section-text="Spatial arguments to functors"><h3 id="spatial-overloads">Spatial arguments to functors</h3><p>In the following subsections, we describe the various spatial arguments that functors can be evaluated at. Almost no functor developers should have to concern themselves with these details as most functor definitions should just appear as functions of space and time, e.g. the same lambda defining the property evaluation should apply across all spatial and temporal arguments. However, in the case that a functor developer wishes to create specific implementations for specific arguments (as illustrated in <code>IMakeMyOwnFunctorProps</code> test class) or simply wishes to know more about the system, we give the details below.</p><p>Any call to a functor looks like the following <code>_foo(const SpatialArg &amp; r, const TemporalArg &amp; t)</code>. Below are the possible type overloads of <code>SpatialArg</code>.</p><section id="40cb8461-b12b-492d-a36a-809122336fc6" data-section-level="4" data-section-text="FaceArg"><h4 id="facearg">FaceArg</h4><p>A <code>struct</code> defining a &quot;face&quot; evaluation calling argument. This is composed of</p><ul class="browser-default"><li><p>a face information object which defines our location in space </p></li><li><p>a limiter which defines how the functor evaluated on either side of the face should be interpolated to the face </p></li><li><p>a boolean which states whether the face information element is upwind of the face </p></li><li><p>a boolean to indicate whether to correct for element skewness </p></li><li><p>a pointer to an element indicating if there is sidedness to the face, and if so, the side of the face. If null, the evaluation should use information from both sides of the face, if the functor is defined on both sides. If not null, the evaluation should ignore information from the other element.</p></li></ul></section><section id="4d1ac1bd-3961-48ac-8bf7-6aa0498c027c" data-section-level="4" data-section-text="ElemArg"><h4 id="elemarg">ElemArg</h4><p>Argument for requesting functor evaluation at an element. This is often used to evaluate constant monomial or finite volume variables. Data in the argument:</p><ul class="browser-default"><li><p>The element of interest </p></li><li><p>Whether to correct for element skewness</p></li></ul></section><section id="aac93d95-cd6f-4667-880f-6b762a27b6e1" data-section-level="4" data-section-text="ElemQpArg"><h4 id="elemqparg">ElemQpArg</h4><p>Argument for requesting functor evaluation at a quadrature point location in an element. Data in the argument:</p><ul class="browser-default"><li><p>The element containing the quadrature point </p></li><li><p>The quadrature point index, e.g. if there are <code>n</code> quadrature points, we are requesting the evaluation of the ith point </p></li><li><p>The quadrature rule that can be used to initialize the functor on the given element</p></li></ul><p>If functors are functions of nonlinear degrees of freedom, evaluation with this argument will likely result in calls to libMesh <code>FE::reinit</code>.</p></section><section id="b1eec102-448e-43ca-b9ae-91e8f448462a" data-section-level="4" data-section-text="ElemSideQpArg"><h4 id="elemsideqparg">ElemSideQpArg</h4><p>Argument for requesting functor evaluation at quadrature point locations on an element side. Data in the argument:</p><ul class="browser-default"><li><p>The element </p></li><li><p>The element side on which the quadrature points are located </p></li><li><p>The quadrature point index, e.g. if there are <code>n</code> quadrature points, we are requesting the evaluation of the ith point </p></li><li><p>The quadrature rule that can be used to initialize the functor on the given element and side</p></li></ul><p>If functors are functions of nonlinear degrees of freedom, evaluation with this argument will likely result in calls to libMesh <code>FE::reinit</code>.</p></section><section id="601888fe-d376-4260-8a29-d6e9fb511a4a" data-section-level="4" data-section-text="ElemPointArg"><h4 id="elempointarg">ElemPointArg</h4><p>Argument for requesting functor evaluation at a point located inside an element. Data in the argument:</p><ul class="browser-default"><li><p>The element containing the point </p></li><li><p>The point to evaluate the functor at </p></li><li><p>Whether to correct for element skewness</p></li></ul></section><section id="286e0dc1-d1c8-4651-8296-c0d64de72ad2" data-section-level="4" data-section-text="Nodes"><h4 id="nodes">Nodes</h4><p>There is currently no nodal argument to functors. Please contact a MOOSE developer if you need this.</p></section></section><section id="a9cb45bd-ce4e-401e-9cbe-e7a9db0b3b17" data-section-level="3" data-section-text="Functor caching"><h3 id="functor-caching">Functor caching</h3><p>By default, functors are always (re-)evaluated every time they are called with <code>operator()</code>. However, the base class <code>Moose::Functor</code> has a <code>setCacheClearanceSchedule(const std::set&lt;ExecFlagType&gt; &amp; clearance_schedule)</code> API that allows control of evaluations (in addition to the <code>clearance_schedule</code> argument to <code>addFunctorProperty</code> introduced above). Supported values for the <code>clearance_schedule</code> are any combination of <code>EXEC_ALWAYS</code>, <code>EXEC_TIMESTEP_BEGIN</code>, <code>EXEC_LINEAR</code>, and <code>EXEC_NONLINEAR</code>. These will cause cached evaluations of functors to be cleared always (in fact not surprisingly in this case we never fill the cache), on <code>timestepSetup</code>, on <code>residualSetup</code>, and on <code>jacobianSetup</code> respectively. If a functor is expected to depend on nonlinear degrees of freedom, then the cache should be cleared on <code>EXEC_LINEAR</code> and <code>EXEC_NONLINEAR</code> (the default <code>EXEC_ALWAYS</code> would obviously also work) in order to achieve a perfect Jacobian. Not surprisingly, if a functor evaluation is cached, then memory usage will increase.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Caching Implementations</div><div class="card-content"><div class="moose-alert-content"><p>Functor caching is only currently implemented for <code>ElemQpArg</code> and <code>ElemSideQpArg</code> spatial overloads. This is with the idea that calls to <code>FE::reinit</code> can be fairly expensive whereas for the other spatial argument types, evaluation of the functors may be relatively inexpensive compared to the memory expense incurred from caching. We may definitely implement caching for other overloads, however, if use cases call for it.</p></div></div></div></section></section></section><div class="moose-modal modal" id="61183640-f47a-4318-9cf9-47a9b791972e"><div class="modal-content"><h4>show_functors</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to print information about the functors in the problem</p></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>