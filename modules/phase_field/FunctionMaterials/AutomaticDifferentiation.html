<!DOCTYPE html><head><meta charset="UTF-8"><title>Automatic Differentiation | Ferret</title><link href="../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../../media/framework/github-logo.png" class="github-mark"></img><img src="../../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="3bb33956-7b7e-4399-bbf0-f793932f3663" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="64b8172a-f68f-4dff-9b8f-c431f2fff452" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="589a6284-49c0-4eb9-84cf-4ad43773d313" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="e82c1df3-2a00-41fa-913e-bc04fb49d7e2" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="6494d121-9048-4112-a1a7-34bb90ca7b9d" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="8c17c330-523a-46bb-9f25-e25d85c4f1c4"><i class="material-icons">menu</i></a><ul class="sidenav" id="8c17c330-523a-46bb-9f25-e25d85c4f1c4"><li><a href="#!" class="dropdown-trigger" data-target="7dac356f-d14a-4910-bfa0-c7531c1e5780" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="50ebfd56-6f7d-4500-a9b3-8dd43b0aaba9" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8a281893-1d58-4a2f-b79b-436db7510dd9" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="964e7745-c435-4a90-ac1d-d4a1b192f0fa" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="5efd77db-f443-45fc-8cbb-c55ccc0d0694" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="3bb33956-7b7e-4399-bbf0-f793932f3663"><li><a href="../../../getting_started/install.html">Install FERRET</a></li><li><a href="../../../getting_started/update.html">Update FERRET</a></li><li><a href="../../../getting_started/running.html">Running FERRET</a></li><li><a href="../../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="64b8172a-f68f-4dff-9b8f-c431f2fff452"><li><a href="../../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="589a6284-49c0-4eb9-84cf-4ad43773d313"><li><a href="../../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="e82c1df3-2a00-41fa-913e-bc04fb49d7e2"><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="6494d121-9048-4112-a1a7-34bb90ca7b9d"><li><a href="../../../syntax/index.html">Complete syntax</a></li><li><a href="../../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="7dac356f-d14a-4910-bfa0-c7531c1e5780"><li><a href="../../../getting_started/install.html">Install FERRET</a></li><li><a href="../../../getting_started/update.html">Update FERRET</a></li><li><a href="../../../getting_started/running.html">Running FERRET</a></li><li><a href="../../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="50ebfd56-6f7d-4500-a9b3-8dd43b0aaba9"><li><a href="../../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="8a281893-1d58-4a2f-b79b-436db7510dd9"><li><a href="../../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="964e7745-c435-4a90-ac1d-d4a1b192f0fa"><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="5efd77db-f443-45fc-8cbb-c55ccc0d0694"><li><a href="../../../syntax/index.html">Complete syntax</a></li><li><a href="../../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="e0e638d4-0905-4491-8226-77720c4cfa5b" data-section-level="1" data-section-text="Automatic Differentiation"><h1 id="automatic-differentiation">Automatic Differentiation</h1><p>Automatic differentiation is a means to construct derivatives of a given expression in a symbolic way. Specifically this means _not_ performing finite differencing.  Derivatives show up the phase field evolution equations (commonly derivatives of both the free energy and the mobilities). Automatic differentiation shifts the burden of computing the derivatives of the oftentimes complex known expressions for the free energies from the user to the software.</p><p>The version of the _Function Parser_ library that ships with MOOSE contains an automatic differentiation feature that is not present in the <a href="http://warp.povusers.org/FunctionParser/">upstream version</a>.</p><p>Include the automatic differentiation module (which also adds <a href="JITCompile">just in time compilation</a> with</p><pre class="moose-pre"><code class="language-cpp">
#include &quot;libmesh/fparser_ad.hh&quot;
</code></pre><p>The module provides the class</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserADBase&lt;Real&gt;
</code></pre><p>which derives from</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserBase&lt;Real&gt;
</code></pre><p>and provides the additional method</p><pre class="moose-pre"><code class="language-cpp">
int AutoDiff(const std::string&amp; var);
</code></pre><p>where <code>var</code> is the name of the variable to take the derivative with respect to. The <code>AutoDiff</code> method must be called on an initialized and parsed (but not optimized) Function Parser object.</p><p>The automatic differentiation system transforms the compiled bytecode of the parsed function into the bytecode of the derivative. The <code>AutoDiff</code> method can be called multiple times to generate high order derivatives.</p><p>The helper method</p><pre class="moose-pre"><code class="language-cpp">
bool isZero();
</code></pre><p>can be called after optimizing the Function Parser object to check if the function is a constant zero (i.e. the bytecode consists only of a <code>push 0</code> command).</p><section id="a7aa49da-89e4-4d51-b9b2-d0e1d8bc4a86" data-section-level="2" data-section-text="Limitations"><h2 id="limitations">Limitations</h2><p>Almost all FParser opcodes are supported, _except_ <code>PCall</code> and <code>FCall</code>, which are function calls to other FParser objects and calls to custom functions.</p><p>The automatic differentiation will currently complain when taking derivatives of functions that are not differentiable in a countable infinite number of points (such as <code>int()</code>), it will however take derivatives of functions like the absolute value <code>abs()</code> that are not differentiable in only a single point. This limitation is arbitrary and may be changed in future versions.</p><p>The current version of the AD module <em>does</em> support differentiating FParser objects that have been previously optimized.</p></section><section id="03a65eb4-716c-4566-855f-adf60a7f6592" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><p>The following code snippet illustrates how to compute and evaluate a derivative:</p><pre class="moose-pre"><code class="language-cpp">
FunctionParserADBase&lt;Real&gt; fparser;
std::string func = &quot;sin(a*x)+x^2*(3+sin(3*x))+a&quot;;

// Parse the input expression into bytecode
fparser.Parse(func, &quot;x,a&quot;);

// transform F -&gt; dF/dx
fparser.AutoDiff(&quot;x&quot;);

// run optimizer to simplify the derivative
fparser.Optimize();

// evaluate the derivative (method from FParserBase&lt;Real&gt;)
Real params[2] = {0.1, 1.7};
std::cout &lt;&lt; fparser.Eval(params) &lt;&lt; std::endl;

// print byte code of the derivative (needs debugging enabled)
fparser.PrintByteCode(std::cout);
</code></pre><p>Not that optimizing the FParser object using <code>.Optimize()</code> after taking the derivative is <em>highly</em> recommended, as the automatic differentiation generates lots of trivial terms. For example the derivative of <code>2*x</code> is <code>0*x+2*1</code>, which will be optimized to <code>2</code>.</p></section><section id="c176b21a-f6c2-480d-8d1d-b7277d2dd335" data-section-level="2" data-section-text="Performance considerations"><h2 id="performance-considerations">Performance considerations</h2><p>The convenience of parsed and automatically differentiated functions does come with a performance penalty. Despite optimizations the parsed functions are slower than hand coded and compiled functions.</p><p>JIT (Just In Time) compilation is available for parsed functions. The JIT system is utilized by adding the <code>enable_jit = true</code> (default) option in the <a href="../../../source/materials/DerivativeParsedMaterial.html"><code>DerivativeParsedMaterial</code></a> block. MOOSE will then attempt to compile the functions and its derivatives into machine code and use it for the residual and Jacobian calculations. This almost fully recovers the performance of hand coded free energies while retaining the flexibility of automatic differentiation.</p></section><section id="006e3603-9d0c-4d74-8583-d48a190eb3bb" data-section-level="2" data-section-text="See also"><h2 id="see-also">See also</h2><ul class="browser-default"><li><p><a href="ExpressionBuilder.html">ExpressionBuilder</a> - building FParser expressions at compile time using operator overloading</p></li></ul></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../../js/init.js"></script><script type="text/javascript" src="../../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../../js/sqa_moose.js"></script>