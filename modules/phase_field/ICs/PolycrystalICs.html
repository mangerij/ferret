<!DOCTYPE html><head><meta charset="UTF-8"><title>Polycrystal Initial Conditions | Ferret</title><link href="../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../../media/framework/github-logo.png" class="github-mark"></img><img src="../../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="0de6b03c-8681-438c-85e8-0c86ecadaab3" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6e9ee1bb-8285-410b-852a-715e26737e4d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d4781692-7026-4841-8976-7b3e05264448" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f1632696-b233-4b5e-8a2b-01a395c67b6a" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="34c6ef1e-a7aa-4286-a6e9-fbee73db17b2" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="3c615869-210b-4cce-97e6-da05211696a5"><i class="material-icons">menu</i></a><ul class="sidenav" id="3c615869-210b-4cce-97e6-da05211696a5"><li><a href="#!" class="dropdown-trigger" data-target="e4fd68fa-4c73-4094-9e31-7b55048e1cb9" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b71ea3fe-e909-4faa-be7e-8e4cd6bd17ae" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f5441912-8394-4762-aa1c-8237b6cd97d8" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7ab432b7-e2a8-4f38-9f64-c7aef5351c3d" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="3e192865-f043-4201-892a-c58a00de0ccd" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="0de6b03c-8681-438c-85e8-0c86ecadaab3"><li><a href="../../../getting_started/install.html">Install FERRET</a></li><li><a href="../../../getting_started/update.html">Update FERRET</a></li><li><a href="../../../getting_started/running.html">Running FERRET</a></li><li><a href="../../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="6e9ee1bb-8285-410b-852a-715e26737e4d"><li><a href="../../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="d4781692-7026-4841-8976-7b3e05264448"><li><a href="../../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="f1632696-b233-4b5e-8a2b-01a395c67b6a"><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="34c6ef1e-a7aa-4286-a6e9-fbee73db17b2"><li><a href="../../../syntax/index.html">Complete syntax</a></li><li><a href="../../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="e4fd68fa-4c73-4094-9e31-7b55048e1cb9"><li><a href="../../../getting_started/install.html">Install FERRET</a></li><li><a href="../../../getting_started/update.html">Update FERRET</a></li><li><a href="../../../getting_started/running.html">Running FERRET</a></li><li><a href="../../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="b71ea3fe-e909-4faa-be7e-8e4cd6bd17ae"><li><a href="../../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="f5441912-8394-4762-aa1c-8237b6cd97d8"><li><a href="../../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="7ab432b7-e2a8-4f38-9f64-c7aef5351c3d"><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="3e192865-f043-4201-892a-c58a00de0ccd"><li><a href="../../../syntax/index.html">Complete syntax</a></li><li><a href="../../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="2c5891d2-4553-4dc8-9414-f5537a009bc4" data-section-level="1" data-section-text="Polycrystal Initial Conditions"><h1 id="polycrystal-initial-conditions">Polycrystal Initial Conditions</h1><p>Polycrystal Initial Conditions can be created in a few ways. They can be read from a file, generated with Voronoi Tesselation of a set of points, or placed in some regular crystal pattern such as hex or circles. In any case, it is advantageous to simulate such a system with a reduced number of order parameters for efficiency, which requires the use of the <a href="../../../source/postprocessors/GrainTracker.html">Grain Tracker</a>. The trickiest part of running a reduced order parameter model however, is the initial assignment of order parameters to grains. This process is akin to solving a <a href="https://en.wikipedia.org/wiki/Graph_coloring">graph coloring</a>. Fortunately, the order parameter assignment process has been taken care of for you. Each polycrystal initial condition should simply extend the PolycrystalUserObjectBase class.</p><div class="card moose-float"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../../media/phase_field/voronoi_flood.png"></img></picture><p class="moose-caption"><span class="moose-caption-text">Grain structure with associated neighbor graph overlaid.</span></p></div></div><p>Extentions of this class must begin by providing reporting the number of grains in the initial condition.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  virtual unsigned int getNumGrains() const = 0;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#c0ab4ad7-79a9-40ba-bc7f-e4da545e47ce">(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</a><p>Additionally, the developer must provide an implementation for reporting the grain(s) at every point in the domain:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  virtual void getGrainsBasedOnPoint(const Point &amp; point,
                                     std::vector&lt;unsigned int&gt; &amp; grains) const = 0;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#de43f785-5cae-4c7d-8506-854424723fb7">(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</a><p>Finally, a method to report the variable value of the current order parameter at a point must be provided. This method is called after order parameters have been assigned to all grains.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  virtual Real getVariableValue(unsigned int op_index, const Point &amp; p) const = 0;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#5d5707a5-350d-4535-a0cd-d5586b8d4372">(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</a><p>The object uses these implementations to build a grain adjacency graph that can be feed to a stochastic or deterministic graph coloring algorithm. MOOSE defaults to using one of the built-in high performance coloring algorithms from the PETSc package. However, a simple backtracking algorithm is also included which works reasonably well on smaller to mid-sized problems.</p><p>The centroids of grains can be randomly generated or read from a file. The use of Maximal Poisson-Disk Sampling (MPS) to generate grain centroids is described in <a href="MPS.html">MPS</a>.</p><p>See:</p><p><a href="../../../source/userobjects/PolycrystalVoronoi.html">PolycrystalVoronoi</a></p><p><a href="../../../source/userobjects/PolycrystalEBSD.html">PolycrystalEBSD</a></p><p><a href="../../../source/userobjects/PolycrystalCircles.html">PolycrystalCircles</a></p><p><a href="../../../source/userobjects/PolycrystalHex.html">PolycrystalHex</a> </p></section><div class="moose-modal modal" id="c0ab4ad7-79a9-40ba-bc7f-e4da545e47ce"><div class="modal-content"><h4>(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;DenseMatrix.h&quot;
#include &quot;FeatureFloodCount.h&quot;

// Forward Declarations

/**
 * This object provides the base capability for creating proper polycrystal ICs. It is
 * able to discover the grain structure to provide information about neighboring grains
 * so that they will not be assigned the same order parameters with a reduced set of variables.
 */
class PolycrystalUserObjectBase : public FeatureFloodCount
{
public:
  static InputParameters validParams();

  PolycrystalUserObjectBase(const InputParameters &amp; parameters);

  /**
   * This callback is triggered after the object is initialized and may be optionally
   * overridden to do precompute the element to grain identifiers ahead of time.
   */
  virtual void precomputeGrainStructure() {}

  /**
   * Method for retrieving active grain IDs based on some point in the mesh. Typically these
   * are element centroids or nodes depending on the basis functions being initialized. ICs that
   * have fixed resolution data (i.e. experimental datasets) may choose to implement
   * the element based method as well for added convenience.
   */
  virtual void getGrainsBasedOnPoint(const Point &amp; point,
                                     std::vector&lt;unsigned int&gt; &amp; grains) const = 0;

  /**
   * This method may be defined in addition to the point based initialization to speed up lookups.
   * It returns grain IDs based on the current element. Note: If your simulation contains adaptivity
   * the point based method may be used to retrieve grain information as well as this method.
   */
  virtual void getGrainsBasedOnElem(const Elem &amp; elem, std::vector&lt;unsigned int&gt; &amp; grains) const
  {
    getGrainsBasedOnPoint(elem.vertex_average(), grains);
  }

  /**
   * Must be overridden by the deriving class to provide the number of grains in the polycrystal
   * structure.
   */
  virtual unsigned int getNumGrains() const = 0;

  /**
   * Returns the variable value for a given op_index and mesh point. This is the method used by the
   * initial condition after the Polycrystal grain structure has be setup. Those grains are
   * then distributed to the typically smaller number of order parameters by this class.
   * This method is then used to return those values but it may be overridden in a derived class.
   */
  virtual Real getVariableValue(unsigned int op_index, const Point &amp; p) const = 0;

  /**
   * Similarly to the getVariableValue method, this method also returns values but may be optimized
   * for returning nodal values.
   */
  virtual Real getNodalVariableValue(unsigned int op_index, const Node &amp; n) const
  {
    return getVariableValue(op_index, static_cast&lt;const Point &amp;&gt;(n));
  }

  /* Returns all available coloring algorithms as an enumeration type for input files.
   */
  static MooseEnum coloringAlgorithms();

  /**
   * Returns corresponding descriptions of available coloring algorithms.
   */
  static std::string coloringAlgorithmDescriptions();

  /**
   * UserObject interface overrides. Derived classes should _not_ override any of these methods.
   */
  virtual void initialSetup() override;
  virtual void initialize() override;
  virtual void execute() override;
  virtual void finalize() override;

protected:
  virtual bool areFeaturesMergeable(const FeatureData &amp; f1, const FeatureData &amp; f2) const override;
  virtual bool isNewFeatureOrConnectedRegion(const DofObject * dof_object,
                                             std::size_t &amp; current_index,
                                             FeatureData *&amp; feature,
                                             Status &amp; status,
                                             unsigned int &amp; new_id) override;
  virtual void prepareDataForTransfer() override;
  virtual void mergeSets() override;
  virtual processor_id_type numberOfDistributedMergeHelpers() const override;
  virtual void restoreOriginalDataStructures(std::vector&lt;std::list&lt;FeatureData&gt;&gt; &amp; orig) override;

  /**
   * Builds a dense adjacency matrix based on the discovery of grain neighbors and halos
   * surrounding each grain.
   */
  void buildGrainAdjacencyMatrix();

  /**
   * Method that runs a coloring algorithm to assign OPs to grains.
   */
  void assignOpsToGrains();

  /**
   * Built-in simple &quot;back-tracking&quot; algorithm to assign colors to a graph.
   */
  bool colorGraph(unsigned int vertex);

  /**
   * Helper method for the back-tracking graph coloring algorithm.
   */
  bool isGraphValid(unsigned int vertex, unsigned int color);

  /**
   * Prints out the adjacency matrix in a nicely spaced integer format.
   */
  void printGrainAdjacencyMatrix() const;

  /*************************************************
   *************** Data Structures *****************
   ************************************************/
  /// The dense adjacency matrix
  std::unique_ptr&lt;DenseMatrix&lt;Real&gt;&gt; _adjacency_matrix;

  /// mesh dimension
  const unsigned int _dim;

  /// The maximum number of order parameters (colors) available to assign to the grain structure
  const unsigned int _op_num;

  /// A map of the grain_id to op
  std::map&lt;unsigned int, unsigned int&gt; _grain_to_op;

  /// The selected graph coloring algorithm used by this object
  const MooseEnum _coloring_algorithm;

  /// A Boolean indicating whether the object has assigned colors to grains (internal use)
  bool _colors_assigned;

  /// A user controllable Boolean which can be used to print the adjacency matrix to the console
  const bool _output_adjacency_matrix;

  /// Used to indicate an invalid coloring for the built-in back-tracking algorithm
  static const unsigned int INVALID_COLOR;

  /// Used to hold the thickness of the halo that should be constructed for detecting adjacency
  static const unsigned int HALO_THICKNESS;

private:
  /// The number of chunks (for merging the features together)
  processor_id_type _num_chunks;

  /// A vector indicating which op is assigned to each grain (by index of the grain)
  std::vector&lt;unsigned int&gt; _grain_idx_to_op;

  /// Temporary storage area for current grains at a point to avoid memory churn
  std::vector&lt;unsigned int&gt; _prealloc_tmp_grains;

  std::map&lt;dof_id_type, std::vector&lt;unsigned int&gt;&gt; _entity_to_grain_cache;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="de43f785-5cae-4c7d-8506-854424723fb7"><div class="modal-content"><h4>(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;DenseMatrix.h&quot;
#include &quot;FeatureFloodCount.h&quot;

// Forward Declarations

/**
 * This object provides the base capability for creating proper polycrystal ICs. It is
 * able to discover the grain structure to provide information about neighboring grains
 * so that they will not be assigned the same order parameters with a reduced set of variables.
 */
class PolycrystalUserObjectBase : public FeatureFloodCount
{
public:
  static InputParameters validParams();

  PolycrystalUserObjectBase(const InputParameters &amp; parameters);

  /**
   * This callback is triggered after the object is initialized and may be optionally
   * overridden to do precompute the element to grain identifiers ahead of time.
   */
  virtual void precomputeGrainStructure() {}

  /**
   * Method for retrieving active grain IDs based on some point in the mesh. Typically these
   * are element centroids or nodes depending on the basis functions being initialized. ICs that
   * have fixed resolution data (i.e. experimental datasets) may choose to implement
   * the element based method as well for added convenience.
   */
  virtual void getGrainsBasedOnPoint(const Point &amp; point,
                                     std::vector&lt;unsigned int&gt; &amp; grains) const = 0;

  /**
   * This method may be defined in addition to the point based initialization to speed up lookups.
   * It returns grain IDs based on the current element. Note: If your simulation contains adaptivity
   * the point based method may be used to retrieve grain information as well as this method.
   */
  virtual void getGrainsBasedOnElem(const Elem &amp; elem, std::vector&lt;unsigned int&gt; &amp; grains) const
  {
    getGrainsBasedOnPoint(elem.vertex_average(), grains);
  }

  /**
   * Must be overridden by the deriving class to provide the number of grains in the polycrystal
   * structure.
   */
  virtual unsigned int getNumGrains() const = 0;

  /**
   * Returns the variable value for a given op_index and mesh point. This is the method used by the
   * initial condition after the Polycrystal grain structure has be setup. Those grains are
   * then distributed to the typically smaller number of order parameters by this class.
   * This method is then used to return those values but it may be overridden in a derived class.
   */
  virtual Real getVariableValue(unsigned int op_index, const Point &amp; p) const = 0;

  /**
   * Similarly to the getVariableValue method, this method also returns values but may be optimized
   * for returning nodal values.
   */
  virtual Real getNodalVariableValue(unsigned int op_index, const Node &amp; n) const
  {
    return getVariableValue(op_index, static_cast&lt;const Point &amp;&gt;(n));
  }

  /* Returns all available coloring algorithms as an enumeration type for input files.
   */
  static MooseEnum coloringAlgorithms();

  /**
   * Returns corresponding descriptions of available coloring algorithms.
   */
  static std::string coloringAlgorithmDescriptions();

  /**
   * UserObject interface overrides. Derived classes should _not_ override any of these methods.
   */
  virtual void initialSetup() override;
  virtual void initialize() override;
  virtual void execute() override;
  virtual void finalize() override;

protected:
  virtual bool areFeaturesMergeable(const FeatureData &amp; f1, const FeatureData &amp; f2) const override;
  virtual bool isNewFeatureOrConnectedRegion(const DofObject * dof_object,
                                             std::size_t &amp; current_index,
                                             FeatureData *&amp; feature,
                                             Status &amp; status,
                                             unsigned int &amp; new_id) override;
  virtual void prepareDataForTransfer() override;
  virtual void mergeSets() override;
  virtual processor_id_type numberOfDistributedMergeHelpers() const override;
  virtual void restoreOriginalDataStructures(std::vector&lt;std::list&lt;FeatureData&gt;&gt; &amp; orig) override;

  /**
   * Builds a dense adjacency matrix based on the discovery of grain neighbors and halos
   * surrounding each grain.
   */
  void buildGrainAdjacencyMatrix();

  /**
   * Method that runs a coloring algorithm to assign OPs to grains.
   */
  void assignOpsToGrains();

  /**
   * Built-in simple &quot;back-tracking&quot; algorithm to assign colors to a graph.
   */
  bool colorGraph(unsigned int vertex);

  /**
   * Helper method for the back-tracking graph coloring algorithm.
   */
  bool isGraphValid(unsigned int vertex, unsigned int color);

  /**
   * Prints out the adjacency matrix in a nicely spaced integer format.
   */
  void printGrainAdjacencyMatrix() const;

  /*************************************************
   *************** Data Structures *****************
   ************************************************/
  /// The dense adjacency matrix
  std::unique_ptr&lt;DenseMatrix&lt;Real&gt;&gt; _adjacency_matrix;

  /// mesh dimension
  const unsigned int _dim;

  /// The maximum number of order parameters (colors) available to assign to the grain structure
  const unsigned int _op_num;

  /// A map of the grain_id to op
  std::map&lt;unsigned int, unsigned int&gt; _grain_to_op;

  /// The selected graph coloring algorithm used by this object
  const MooseEnum _coloring_algorithm;

  /// A Boolean indicating whether the object has assigned colors to grains (internal use)
  bool _colors_assigned;

  /// A user controllable Boolean which can be used to print the adjacency matrix to the console
  const bool _output_adjacency_matrix;

  /// Used to indicate an invalid coloring for the built-in back-tracking algorithm
  static const unsigned int INVALID_COLOR;

  /// Used to hold the thickness of the halo that should be constructed for detecting adjacency
  static const unsigned int HALO_THICKNESS;

private:
  /// The number of chunks (for merging the features together)
  processor_id_type _num_chunks;

  /// A vector indicating which op is assigned to each grain (by index of the grain)
  std::vector&lt;unsigned int&gt; _grain_idx_to_op;

  /// Temporary storage area for current grains at a point to avoid memory churn
  std::vector&lt;unsigned int&gt; _prealloc_tmp_grains;

  std::map&lt;dof_id_type, std::vector&lt;unsigned int&gt;&gt; _entity_to_grain_cache;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5d5707a5-350d-4535-a0cd-d5586b8d4372"><div class="modal-content"><h4>(../moose/modules/phase_field/include/userobjects/PolycrystalUserObjectBase.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;DenseMatrix.h&quot;
#include &quot;FeatureFloodCount.h&quot;

// Forward Declarations

/**
 * This object provides the base capability for creating proper polycrystal ICs. It is
 * able to discover the grain structure to provide information about neighboring grains
 * so that they will not be assigned the same order parameters with a reduced set of variables.
 */
class PolycrystalUserObjectBase : public FeatureFloodCount
{
public:
  static InputParameters validParams();

  PolycrystalUserObjectBase(const InputParameters &amp; parameters);

  /**
   * This callback is triggered after the object is initialized and may be optionally
   * overridden to do precompute the element to grain identifiers ahead of time.
   */
  virtual void precomputeGrainStructure() {}

  /**
   * Method for retrieving active grain IDs based on some point in the mesh. Typically these
   * are element centroids or nodes depending on the basis functions being initialized. ICs that
   * have fixed resolution data (i.e. experimental datasets) may choose to implement
   * the element based method as well for added convenience.
   */
  virtual void getGrainsBasedOnPoint(const Point &amp; point,
                                     std::vector&lt;unsigned int&gt; &amp; grains) const = 0;

  /**
   * This method may be defined in addition to the point based initialization to speed up lookups.
   * It returns grain IDs based on the current element. Note: If your simulation contains adaptivity
   * the point based method may be used to retrieve grain information as well as this method.
   */
  virtual void getGrainsBasedOnElem(const Elem &amp; elem, std::vector&lt;unsigned int&gt; &amp; grains) const
  {
    getGrainsBasedOnPoint(elem.vertex_average(), grains);
  }

  /**
   * Must be overridden by the deriving class to provide the number of grains in the polycrystal
   * structure.
   */
  virtual unsigned int getNumGrains() const = 0;

  /**
   * Returns the variable value for a given op_index and mesh point. This is the method used by the
   * initial condition after the Polycrystal grain structure has be setup. Those grains are
   * then distributed to the typically smaller number of order parameters by this class.
   * This method is then used to return those values but it may be overridden in a derived class.
   */
  virtual Real getVariableValue(unsigned int op_index, const Point &amp; p) const = 0;

  /**
   * Similarly to the getVariableValue method, this method also returns values but may be optimized
   * for returning nodal values.
   */
  virtual Real getNodalVariableValue(unsigned int op_index, const Node &amp; n) const
  {
    return getVariableValue(op_index, static_cast&lt;const Point &amp;&gt;(n));
  }

  /* Returns all available coloring algorithms as an enumeration type for input files.
   */
  static MooseEnum coloringAlgorithms();

  /**
   * Returns corresponding descriptions of available coloring algorithms.
   */
  static std::string coloringAlgorithmDescriptions();

  /**
   * UserObject interface overrides. Derived classes should _not_ override any of these methods.
   */
  virtual void initialSetup() override;
  virtual void initialize() override;
  virtual void execute() override;
  virtual void finalize() override;

protected:
  virtual bool areFeaturesMergeable(const FeatureData &amp; f1, const FeatureData &amp; f2) const override;
  virtual bool isNewFeatureOrConnectedRegion(const DofObject * dof_object,
                                             std::size_t &amp; current_index,
                                             FeatureData *&amp; feature,
                                             Status &amp; status,
                                             unsigned int &amp; new_id) override;
  virtual void prepareDataForTransfer() override;
  virtual void mergeSets() override;
  virtual processor_id_type numberOfDistributedMergeHelpers() const override;
  virtual void restoreOriginalDataStructures(std::vector&lt;std::list&lt;FeatureData&gt;&gt; &amp; orig) override;

  /**
   * Builds a dense adjacency matrix based on the discovery of grain neighbors and halos
   * surrounding each grain.
   */
  void buildGrainAdjacencyMatrix();

  /**
   * Method that runs a coloring algorithm to assign OPs to grains.
   */
  void assignOpsToGrains();

  /**
   * Built-in simple &quot;back-tracking&quot; algorithm to assign colors to a graph.
   */
  bool colorGraph(unsigned int vertex);

  /**
   * Helper method for the back-tracking graph coloring algorithm.
   */
  bool isGraphValid(unsigned int vertex, unsigned int color);

  /**
   * Prints out the adjacency matrix in a nicely spaced integer format.
   */
  void printGrainAdjacencyMatrix() const;

  /*************************************************
   *************** Data Structures *****************
   ************************************************/
  /// The dense adjacency matrix
  std::unique_ptr&lt;DenseMatrix&lt;Real&gt;&gt; _adjacency_matrix;

  /// mesh dimension
  const unsigned int _dim;

  /// The maximum number of order parameters (colors) available to assign to the grain structure
  const unsigned int _op_num;

  /// A map of the grain_id to op
  std::map&lt;unsigned int, unsigned int&gt; _grain_to_op;

  /// The selected graph coloring algorithm used by this object
  const MooseEnum _coloring_algorithm;

  /// A Boolean indicating whether the object has assigned colors to grains (internal use)
  bool _colors_assigned;

  /// A user controllable Boolean which can be used to print the adjacency matrix to the console
  const bool _output_adjacency_matrix;

  /// Used to indicate an invalid coloring for the built-in back-tracking algorithm
  static const unsigned int INVALID_COLOR;

  /// Used to hold the thickness of the halo that should be constructed for detecting adjacency
  static const unsigned int HALO_THICKNESS;

private:
  /// The number of chunks (for merging the features together)
  processor_id_type _num_chunks;

  /// A vector indicating which op is assigned to each grain (by index of the grain)
  std::vector&lt;unsigned int&gt; _grain_idx_to_op;

  /// Temporary storage area for current grains at a point to avoid memory churn
  std::vector&lt;unsigned int&gt; _prealloc_tmp_grains;

  std::map&lt;dof_id_type, std::vector&lt;unsigned int&gt;&gt; _entity_to_grain_cache;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../../js/init.js"></script><script type="text/javascript" src="../../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../../js/sqa_moose.js"></script>