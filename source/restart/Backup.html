<!DOCTYPE html><head><meta charset="UTF-8"><title>Backup | Ferret</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="19f963cd-76a2-4d40-947d-caa7f825990d" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ea4d7580-327a-4d04-b9c1-6716d77e28c9" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="60eb06d6-3aa3-4a6d-837b-b928ae447b9d" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="55b6e3a8-48ac-4466-b275-f960e81c62bd" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="34888f97-6221-4458-bec0-7d6e9068a582" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="ac6ebfc7-12ef-4fe1-8c1d-f5594abd740f"><i class="material-icons">menu</i></a><ul class="sidenav" id="ac6ebfc7-12ef-4fe1-8c1d-f5594abd740f"><li><a href="#!" class="dropdown-trigger" data-target="84b48bd8-b616-4bbb-aac5-5b1c7c28e924" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="4596f337-840a-4d3c-abea-5bd54184d5e6" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="5d6a3ab2-25da-49f7-9643-fcbdf6fc6913" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9bb088b7-cfdb-4129-bdbe-99ca17a45766" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="93eed025-859e-4517-b723-248d706609fd" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="19f963cd-76a2-4d40-947d-caa7f825990d"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="ea4d7580-327a-4d04-b9c1-6716d77e28c9"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="60eb06d6-3aa3-4a6d-837b-b928ae447b9d"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="55b6e3a8-48ac-4466-b275-f960e81c62bd"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="34888f97-6221-4458-bec0-7d6e9068a582"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="84b48bd8-b616-4bbb-aac5-5b1c7c28e924"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="4596f337-840a-4d3c-abea-5bd54184d5e6"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="5d6a3ab2-25da-49f7-9643-fcbdf6fc6913"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="9bb088b7-cfdb-4129-bdbe-99ca17a45766"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="93eed025-859e-4517-b723-248d706609fd"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="d8080b22-cf05-4ab5-93c4-cacd9055e757" data-section-level="1" data-section-text="Backup"><h1 id="backup">Backup</h1><p>The Backup object is a simply a <code>struct</code> for holding binary blob &quot;checkpoint&quot; data. The object contains a stream for holding global simulation state data along with a separate vector for holding individual thread state for each thread in the simulation. The Backup object is part of the larger Restart/Recovery system in MOOSE.</p><p>The Backup object contains the serialized data from MOOSE&#x27;s <code>dataLoad/dataStore</code> routines found in <a class="moose-source-filename tooltipped modal-trigger" href="#6035c20d-5e37-4f97-9380-1a2bdbca3a90">DataIO.h</a>. </p></section><div class="moose-modal modal" id="6035c20d-5e37-4f97-9380-1a2bdbca3a90"><div class="modal-content"><h4>(../moose/framework/include/restart/DataIO.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;DualReal.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;HashMap.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;RankTwoTensor.h&quot;
#include &quot;RankThreeTensor.h&quot;
#include &quot;RankFourTensor.h&quot;
#include &quot;ColumnMajorMatrix.h&quot;

#include &quot;libmesh/parallel.h&quot;
#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
#include &lt;type_traits&gt;
#endif

// C++ includes
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;memory&gt;

namespace libMesh
{
template &lt;typename T&gt;
class NumericVector;
template &lt;typename T&gt;
class DenseMatrix;
template &lt;typename T&gt;
class DenseVector;
template &lt;typename T&gt;
class VectorValue;
template &lt;typename T&gt;
class TensorValue;
class Elem;
class Point;
}

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique pointer helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * HashMap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

/**
 * Scalar helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, P &amp; data, void * context);

/**
 * Vector helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context);

/**
 * Shared Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Unique Pointer helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context);

/**
 * Set helper routine
 */
template &lt;typename P&gt;
inline void loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context);

/**
 * Map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Unordered_map helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context);

/**
 * Hashmap helper routine
 */
template &lt;typename P, typename Q&gt;
inline void loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context);

template &lt;typename T&gt;
inline void dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/);

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Store Declarations *****************
template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, T &amp; v, void * /*context*/)
{
#ifdef LIBMESH_HAVE_CXX11_TYPE_TRAITS
  static_assert(std::is_polymorphic&lt;T&gt;::value == false,
                &quot;Cannot serialize a class that has virtual &quot;
                &quot;members!\nWrite a custom dataStore() &quot;
                &quot;template specialization!\n\n&quot;);
  static_assert(std::is_trivially_copyable&lt;T&gt;::value,
                &quot;Cannot serialize a class that is not trivially copyable!\nWrite a custom &quot;
                &quot;dataStore() template specialization!\n\n&quot;);
#endif

  // Moose::out&lt;&lt;&quot;Generic dataStore&quot;&lt;&lt;std::endl;
  stream.write((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to store&quot;);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to store a raw pointer type: \&quot;&quot;,
             demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataStore() template specialization!\n\n&quot;);
}

void dataStore(std::ostream &amp; stream, Point &amp; p, void * context);

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  storeHelper(stream, p.first, context);
  storeHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First store the size of the vector
  unsigned int size = v.size();
  dataStore(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
    storeHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  storeHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First store the size of the set
  unsigned int size = s.size();
  dataStore(stream, size, nullptr);

  typename std::set&lt;T&gt;::iterator it = s.begin();
  typename std::set&lt;T&gt;::iterator end = s.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the set
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::list&lt;T&gt;::iterator it = l.begin();
  typename std::list&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T&gt;
inline void
dataStore(std::ostream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First store the size of the container
  unsigned int size = l.size();
  dataStore(stream, size, nullptr);

  typename std::deque&lt;T&gt;::iterator it = l.begin();
  typename std::deque&lt;T&gt;::iterator end = l.end();

  for (; it != end; ++it)
  {
    T &amp; x = const_cast&lt;T &amp;&gt;(*it);
    storeHelper(stream, x, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::map&lt;T, U&gt;::iterator it = m.begin();
  typename std::map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename std::unordered_map&lt;T, U&gt;::iterator it = m.begin();
  typename std::unordered_map&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataStore(std::ostream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First store the size of the map
  unsigned int size = m.size();
  dataStore(stream, size, nullptr);

  typename HashMap&lt;T, U&gt;::iterator it = m.begin();
  typename HashMap&lt;T, U&gt;::iterator end = m.end();

  for (; it != end; ++it)
  {
    T &amp; key = const_cast&lt;T &amp;&gt;(it-&gt;first);

    storeHelper(stream, key, context);

    storeHelper(stream, it-&gt;second, context);
  }
}

// Specializations (defined in .C)
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Real &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::string &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, VariableName &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, bool &amp; v, void * context);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, const Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, Node *&amp; n, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, DualReal &amp; dn, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, RealEigenVector &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, RealEigenMatrix &amp; v, void * context);
template &lt;&gt;
void dataStore(std::ostream &amp; stream, libMesh::Parameters &amp; p, void * context);

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, std::array&lt;DualReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataStore(std::ostream &amp; stream, DualReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataStore(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, NumericVector&lt;T&gt; &amp; v, void * context)
{
  v.close();

  numeric_index_type size = v.local_size();

  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;&gt;
void dataStore(std::ostream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int m = v.size();
  dataStore(stream, m, nullptr);
  for (unsigned int i = 0; i &lt; v.size(); i++)
  {
    T r = v(i);
    dataStore(stream, r, context);
  }
}

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataStore(std::ostream &amp; stream, VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataStore(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataStore(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; srtt, void * context)
{
  dataStore(stream, srtt._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; srft, void * context)
{
  dataStore(stream, srft._vals, context);
}

template &lt;typename T&gt;
void
dataStore(std::ostream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataStore(stream, cmm._values, context);
}

// DO NOT MODIFY THE NEXT LINE - It is used by MOOSEDocs
// *************** Global Load Declarations *****************
template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, T &amp; v, void * /*context*/)
{
  stream.read((char *)&amp;v, sizeof(v));
  mooseAssert(!stream.bad(), &quot;Failed to load&quot;);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; /*stream*/, T *&amp; /*v*/, void * /*context*/)
{
  mooseError(&quot;Attempting to load a raw pointer type: \&quot;&quot;,
             demangle(typeid(T).name()),
             &quot; *\&quot; as restartable data!\nWrite a custom dataLoad() template specialization!\n\n&quot;);
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::pair&lt;T, U&gt; &amp; p, void * context)
{
  loadHelper(stream, p.first, context);
  loadHelper(stream, p.second, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::vector&lt;T&gt; &amp; v, void * context)
{
  // First read the size of the vector
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  v.resize(size);

  for (unsigned int i = 0; i &lt; size; i++)
    loadHelper(stream, v[i], context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::shared_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::unique_ptr&lt;T&gt; &amp; v, void * context)
{
  T * tmp = v.get();

  loadHelper(stream, tmp, context);
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::set&lt;T&gt; &amp; s, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    s.insert(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::list&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the set
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T&gt;
inline void
dataLoad(std::istream &amp; stream, std::deque&lt;T&gt; &amp; l, void * context)
{
  // First read the size of the container
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T data;
    loadHelper(stream, data, context);
    l.push_back(std::move(data));
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, std::unordered_map&lt;T, U&gt; &amp; m, void * context)
{
  m.clear();

  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

template &lt;typename T, typename U&gt;
inline void
dataLoad(std::istream &amp; stream, HashMap&lt;T, U&gt; &amp; m, void * context)
{
  // First read the size of the map
  unsigned int size = 0;
  dataLoad(stream, size, nullptr);

  for (unsigned int i = 0; i &lt; size; i++)
  {
    T key;
    loadHelper(stream, key, context);

    U &amp; value = m[key];
    loadHelper(stream, value, context);
  }
}

// Specializations (defined in .C)
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Real &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::string &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, VariableName &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, bool &amp; v, void * /*context*/);
// Vectors of bools are special
// https://en.wikipedia.org/w/index.php?title=Sequence_container_(C%2B%2B)&amp;oldid=767869909#Specialization_for_bool
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::vector&lt;bool&gt; &amp; v, void * /*context*/);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, const Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Elem *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, Node *&amp; e, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, std::stringstream &amp; s, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, DualReal &amp; dn, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, RealEigenVector &amp; v, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, RealEigenMatrix &amp; v, void * context);
template &lt;&gt;
void dataLoad(std::istream &amp; stream, libMesh::Parameters &amp; p, void * context);

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, std::array&lt;DualReal, N&gt; &amp; dn, void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;std::size_t N&gt;
inline void
dataLoad(std::istream &amp; stream, DualReal (&amp;dn)[N], void * context)
{
  for (std::size_t i = 0; i &lt; N; ++i)
    dataLoad(stream, dn[i], context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, NumericVector&lt;T&gt; &amp; v, void * context)
{
  numeric_index_type size = v.local_size();
  for (numeric_index_type i = v.first_local_index(); i &lt; v.first_local_index() + size; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v.set(i, r);
  }
  v.close();
}

template &lt;&gt;
void dataLoad(std::istream &amp; stream, Vec &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, DenseVector&lt;T&gt; &amp; v, void * context)
{
  unsigned int n = 0;
  dataLoad(stream, n, nullptr);
  v.resize(n);
  for (unsigned int i = 0; i &lt; n; i++)
  {
    T r = 0;
    dataLoad(stream, r, context);
    v(i) = r;
  }
}

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, TensorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, DenseMatrix&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void dataLoad(std::istream &amp; stream, VectorValue&lt;T&gt; &amp; v, void * context);

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._coords, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankThreeTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, RankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankTwoTensorTempl&lt;T&gt; &amp; rtt, void * context)
{
  dataLoad(stream, rtt._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, SymmetricRankFourTensorTempl&lt;T&gt; &amp; rft, void * context)
{
  dataLoad(stream, rft._vals, context);
}

template &lt;typename T&gt;
void
dataLoad(std::istream &amp; stream, ColumnMajorMatrixTempl&lt;T&gt; &amp; cmm, void * context)
{
  dataLoad(stream, cmm._values, context);
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, P &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// std::unique Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
storeHelper(std::ostream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
storeHelper(std::ostream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataStore(stream, data, context);
}

// Scalar Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, P &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Vector Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::vector&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// std::shared_ptr Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::shared_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unique Pointer Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::unique_ptr&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Set Helper Function
template &lt;typename P&gt;
inline void
loadHelper(std::istream &amp; stream, std::set&lt;P&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// Unordered_map Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, std::unordered_map&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

// HashMap Helper Function
template &lt;typename P, typename Q&gt;
inline void
loadHelper(std::istream &amp; stream, HashMap&lt;P, Q&gt; &amp; data, void * context)
{
  dataLoad(stream, data, context);
}

void dataLoad(std::istream &amp; stream, Point &amp; p, void * context);

#ifndef TIMPI_HAVE_STRING_PACKING
/**
 * The following methods are specializations for using the libMesh::Parallel::packed_range_*
 * routines
 * for std::strings. These are here because the dataLoad/dataStore routines create raw string
 * buffers that can be communicated in a standard way using packed ranges.
 */
namespace libMesh
{
namespace Parallel
{
template &lt;typename T&gt;
class Packing&lt;std::basic_string&lt;T&gt;&gt;
{
public:
  static const unsigned int size_bytes = 4;

  typedef T buffer_type;

  static unsigned int get_string_len(typename std::vector&lt;T&gt;::const_iterator in)
  {
    unsigned int string_len = reinterpret_cast&lt;const unsigned char &amp;&gt;(in[size_bytes - 1]);
    for (signed int i = size_bytes - 2; i &gt;= 0; --i)
    {
      string_len *= 256;
      string_len += reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i]);
    }
    return string_len;
  }

  static unsigned int packed_size(typename std::vector&lt;T&gt;::const_iterator in)
  {
    return get_string_len(in) + size_bytes;
  }

  static unsigned int packable_size(const std::basic_string&lt;T&gt; &amp; s, const void *)
  {
    return s.size() + size_bytes;
  }

  template &lt;typename Iter&gt;
  static void pack(const std::basic_string&lt;T&gt; &amp; b, Iter data_out, const void *)
  {
    unsigned int string_len = b.size();
    for (unsigned int i = 0; i != size_bytes; ++i)
    {
      *data_out++ = (string_len % 256);
      string_len /= 256;
    }

    std::copy(b.begin(), b.end(), data_out);
  }

  static std::basic_string&lt;T&gt; unpack(typename std::vector&lt;T&gt;::const_iterator in, void *)
  {
    unsigned int string_len = get_string_len(in);

    std::ostringstream oss;
    for (unsigned int i = 0; i &lt; string_len; ++i)
      oss &lt;&lt; reinterpret_cast&lt;const unsigned char &amp;&gt;(in[i + size_bytes]);

    in += size_bytes + string_len;

    return oss.str();
  }
};

} // namespace Parallel

} // namespace libMesh

#endif

/**
 * Stores the data \p v in a &quot;skippable&quot; sense. That is, when it is loaded,
 * its data can be skipped through.
 *
 * The resulting data _must_ be loaded with dataLoadSkippable or dataLoadSkip.
 */
template &lt;typename T&gt;
void dataStoreSkippable(std::ostream &amp; stream, T &amp; v, void * context);
/**
 * Loads a piece of &quot;skippable&quot; data. See dataStoreSkippable.
 */
template &lt;typename T&gt;
void dataLoadSkippable(std::istream &amp; stream, T &amp; v, void * context);
/**
 * Skips a piece of &quot;skippable&quot; data. See dataStoreSkippable.
 */
void dataLoadSkip(std::istream &amp; stream);

template &lt;typename T&gt;
inline void
dataStoreSkippable(std::ostream &amp; stream, T &amp; v, void * context)
{
  std::stringstream data_stream;
  dataStore(data_stream, v, context);

  // We have an extra std::size_t value because the store of
  // std::stringstream also stores the size
  std::size_t data_stream_size =
      static_cast&lt;std::size_t&gt;(data_stream.tellp()) + sizeof(std::size_t);
  dataStore(stream, data_stream_size, nullptr);

  dataStore(stream, data_stream, nullptr);
}

template &lt;typename T&gt;
inline void
dataLoadSkippable(std::istream &amp; stream, T &amp; v, void * context)
{
  std::size_t data_stream_size;
  dataLoad(stream, data_stream_size, nullptr);

  std::stringstream data_stream;
  dataLoad(stream, data_stream, nullptr);

  dataLoad(data_stream, v, context);
}

inline void
dataLoadSkip(std::istream &amp; stream)
{
  std::size_t data_stream_size;
  dataLoad(stream, data_stream_size, nullptr);

  stream.seekg(data_stream_size, std::ios::cur);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>