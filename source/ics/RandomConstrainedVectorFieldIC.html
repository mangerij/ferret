<!DOCTYPE html><head><meta charset="UTF-8"><title>RandomConstrainedVectorFieldIC | Ferret</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="18b4b261-7f7b-4cbc-a168-aa6b5995a243" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="0ac70e91-9f52-46ed-a44a-16d820432bb8" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f31425c0-140a-410b-b279-be6503d850c2" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="31344239-afdc-4c22-aab4-d97d88ebbb18" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="175e1051-0bc8-4b05-8593-54ce8b4a4087" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="36c48471-82be-410a-92a8-399e6fe68461"><i class="material-icons">menu</i></a><ul class="sidenav" id="36c48471-82be-410a-92a8-399e6fe68461"><li><a href="#!" class="dropdown-trigger" data-target="8293a5d3-1bb3-44ea-bf34-894f8ceb54d5" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="124150a7-06f9-4c3d-8668-8f059b66dc64" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="739c5d4f-650c-4c3b-a214-510afa3bc41b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="05cd3801-7d47-46c8-b5a1-046e7ecfb5ea" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="d7bbd5d1-05e4-4be5-9687-80434085b4d6" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="18b4b261-7f7b-4cbc-a168-aa6b5995a243"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="0ac70e91-9f52-46ed-a44a-16d820432bb8"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="f31425c0-140a-410b-b279-be6503d850c2"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="31344239-afdc-4c22-aab4-d97d88ebbb18"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="175e1051-0bc8-4b05-8593-54ce8b4a4087"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="8293a5d3-1bb3-44ea-bf34-894f8ceb54d5"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="124150a7-06f9-4c3d-8668-8f059b66dc64"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="739c5d4f-650c-4c3b-a214-510afa3bc41b"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="05cd3801-7d47-46c8-b5a1-046e7ecfb5ea"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="d7bbd5d1-05e4-4be5-9687-80434085b4d6"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="6c1d81e2-217a-4b30-b619-f2c8844d0863" data-section-level="1" data-section-text="RandomConstrainedVectorFieldIC"><h1 id="randomconstrainedvectorfieldic">RandomConstrainedVectorFieldIC</h1><p></p><section id="4d3405dd-6105-41cc-a359-a6f19439ed1c" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>Seeds a vector field that is constrained to the unit sphere. Typically useful as <code>ICs</code> for micromagnetic simulations where <span class="moose-katex-inline-equation" id="moose-equation-03bd6c28-990b-44ee-a274-3f7eb89d5f15"><script>var element = document.getElementById("moose-equation-03bd6c28-990b-44ee-a274-3f7eb89d5f15");katex.render("|\\mathbf{m}| = 1", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> with random or pseudo-random angles. The usual spherical coordinate prescription is used with <span class="moose-katex-inline-equation" id="moose-equation-607de228-9fed-4d9a-ac9d-9c13aee1314a"><script>var element = document.getElementById("moose-equation-607de228-9fed-4d9a-ac9d-9c13aee1314a");katex.render("\\phi", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-53d3f7a5-68f2-4151-a896-5c19c1dea297"><script>var element = document.getElementById("moose-equation-53d3f7a5-68f2-4151-a896-5c19c1dea297");katex.render("\\theta", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> the azimuthal and polar angles respectively.</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-0f9edfde-5d4b-4823-bcb0-04dfdcdd3352"></span><script>var element = document.getElementById("moose-equation-0f9edfde-5d4b-4823-bcb0-04dfdcdd3352");katex.render("  \\begin{aligned}     m_x &= M_s^0 \\cos{\\left(\\phi\\right)} \\sin{\\left(\\theta\\right)} \\\\     m_y &= M_s^0 \\sin{\\left(\\phi\\right)} \\sin{\\left(\\theta\\right)} \\\\     m_z &= M_s^0 \\cos{\\left(\\theta\\right)}.   \\end{aligned}", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span></p><p>The parameter <span class="moose-katex-inline-equation" id="moose-equation-a7a316aa-affa-4d16-8208-07b6935522a3"><script>var element = document.getElementById("moose-equation-a7a316aa-affa-4d16-8208-07b6935522a3");katex.render("M_s^0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> can be used to constrain the <code>ICs</code> to something other than the unit sphere if needed.</p></section><section id="9d6d3971-fdd8-47f2-893c-fe2cf7b913ed" data-section-level="2" data-section-text="Example Input File Syntax"><h2 id="example-input-file-syntax">Example Input File Syntax</h2><pre class="moose-pre" style="max-height:350px;"><code class="language-python">[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component = 2
    [../]
  [../]

  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
[]
</code></pre><p>Note that <span class="moose-katex-inline-equation" id="moose-equation-4403280c-3b42-4ba5-93a1-c7121c0e486e"><script>var element = document.getElementById("moose-equation-4403280c-3b42-4ba5-93a1-c7121c0e486e");katex.render("\\phi", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-7b3c94f5-8937-4d5e-b59b-98ccc4eeb818"><script>var element = document.getElementById("moose-equation-7b3c94f5-8937-4d5e-b59b-98ccc4eeb818");katex.render("\\theta", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\tr":"\\text{tr}","\\dev":"\\text{dev}","\\sym":"\\text{sym}","\\diff":"\\text{ d}#1","\\activepart":"{\\left< A \\right>}","\\inactivepart":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\ep":"{\\varepsilon^p}","\\ep0":"{\\varepsilon_0^p}","\\epdot":"{\\dot{\\varepsilon}}^p","\\epdot0":"{\\dot{\\varepsilon}}_0^p","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> are fields that are seeded via <code>AuxVariables</code> in this example.</p></section><section id="8cc5de81-9c25-408c-8f10-ae494d73af28" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="08a1b7cd-ba39-43c4-a34b-aa12b8aabfa8" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">M0s</span><span class="moose-parameter-header-description">M0s</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>M0s</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">component</span><span class="moose-parameter-header-description">An integer corresponding to the direction the variable this IC is set. (0 for x, 1 for y, 2.0 for z)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An integer corresponding to the direction the variable this IC is set. (0 for x, 1 for y, 2.0 for z)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">phi</span><span class="moose-parameter-header-description">The field of random azimuthal angles</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The field of random azimuthal angles</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">theta</span><span class="moose-parameter-header-description">The field of random polar angles</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The field of random polar angles</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The variable this initial condition is supposed to provide values for.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>VariableName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The variable this initial condition is supposed to provide values for.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="eb2e2878-a2fe-4dd9-9a25-b6c05ee4e90f" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundaries (ids or names) from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundaries (ids or names) from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="a84cc09e-5ce0-46eb-9d33-cf3147095518" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">ignore_uo_dependency</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">When set to true, a UserObject retrieved by this IC will not be executed before the this IC</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When set to true, a UserObject retrieved by this IC will not be executed before the this IC</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section id="ad5f3c8e-a1c4-46a4-b631-d2da81a0b1c5" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a class="moose-source-filename tooltipped modal-trigger" href="#23bec754-ef91-4d64-ab9c-6582079fb434">(test/tests/magnets/mag_brick.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#c7c9c008-2542-49bc-92b4-a19ebfecd145">(tutorial/AFMR_MnF2_ex.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#1da862f7-17be-4cae-b5e2-c8cf2277e9e7">(test/tests/magnets/slab_PML_small.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#0ac4fdea-aab7-4278-8a1a-f76ccc713ccd">(tutorial/ringdown.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#54f0fb1f-d00f-4838-a615-78348a565844">(test/tests/magnets/magnetostatic_brick.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#587f9394-f056-4032-b606-6cb59a27b7bc">(test/tests/magnets/ringdown.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#6ac908b3-882f-45b7-adf7-14547e54d970">(test/tests/magnets/AFMR_MnF2_ex.i)</a></li></ul></section></section><div class="moose-modal modal" id="23bec754-ef91-4d64-ab9c-6582079fb434"><div class="modal-content"><h4>(test/tests/magnets/mag_brick.i)</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  [./fmg]
    type = FileMeshGenerator
    file = exodus_dx2_x10_y10_z30_b100.e
  []

  [central_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = fmg
    master_block = &#x27;1&#x27;
    paired_block = &#x27;2&#x27;
    primary_block = &#x27;1&#x27;
    new_boundary = &#x27;70&#x27;
  []
[]


[GlobalParams]
  mag_x = mag_x
  mag_y = mag_y
  mag_z = mag_z

  potential_H_int = potential_H_int
[]

[Materials]
  [./constants]
    type = GenericConstantMaterial
    prop_names = &#x27; alpha    Ae    Ms          g0          mu0         nx ny nz &#x27;
    prop_values = &#x27;0.01    0.013   1.2      221010.0   1256.64        0  1  1  &#x27;
  [../]

  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
  [../]

  [./aniso]
    type = GenericConstantMaterial
    prop_names = &#x27;K1 K2&#x27;
    prop_values = &#x27;20.0 0&#x27;        #  positive is unaxial
  [../]
  [./permitivitty_1]
    type = GenericConstantMaterial
    prop_names = &#x27;permittivity&#x27;  # dummy variable at the moment since we use the &quot;electrostatics&quot; kernel
    prop_values = &#x27;1.0&#x27;
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]

  ###############################
  ##                           ##
  ## Define the function for   ##
  ##       alpha_long          ##
  ##                           ##
  ## here is just a (large)    ##
  ## constant                  ##
  ##                           ##
  ###############################

  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;
    vars = &#x27;st&#x27;
    vals = &#x27;1e3&#x27;
  [../]
[]

[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 2
    [../]
  [../]

  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxVariables]
  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#
  [./azimuth_phi]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.3
      max = 0.31
      seed = 2
    [../]
  [../]
  [./polar_theta]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 1.4
      max = 1.41
      seed = 37
    [../]
  [../]

  [./mag_s]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]

  [./H_x]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
  [./H_y]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
  [./H_z]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]

  [./azimuth_phi_mag_min1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.0
      max = 0.00001
      seed = 2
    [../]
  [../]
  [./polar_theta_mag_min1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.0
      max = 0.00001
      seed = 37
    [../]
  [../]
[]

[AuxKernels]

  #---------------------------------------#
  #                                       #
  #       compute magnitude of m          #
  #                                       #
  #---------------------------------------#

  [./mag_mag]
    type = VectorMag
    variable = mag_s
    vector_x = mag_x
    vector_y = mag_y
    vector_z = mag_z
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    compute demag field grad*Phi       #
  #                                       #
  #---------------------------------------#

  [./hxo]
    type = DemagFieldAux
    component = 0
    variable = H_x
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./hyo]
    type = DemagFieldAux
    component = 1
    variable = H_y
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./hzo]
    type = DemagFieldAux
    component = 2
    variable = H_z
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
[]

[Kernels]

  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag_x_time]
    type = TimeDerivative
    variable = mag_x
    block = &#x27;1&#x27;
  [../]
  [./mag_y_time]
    type = TimeDerivative
    variable = mag_y
    block = &#x27;1&#x27;
  [../]
  [./mag_z_time]
    type = TimeDerivative
    variable = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #       Exchange stiffness              #
  #                                       #
  #---------------------------------------#

  [./dllg_x_exch]
    type = MasterExchangeCartLLG
    variable = mag_x
    component = 0
  [../]
  [./dllg_y_exch]
    type = MasterExchangeCartLLG
    variable = mag_y
    component = 1
  [../]
  [./dllg_z_exch]
    type = MasterExchangeCartLLG
    variable = mag_z
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #         anisotropy                    #
  #                                       #
  #---------------------------------------#

  [./d_aM_x]
    type = MasterAnisotropyCartLLG
    variable = mag_x
    component = 0
  [../]
  [./d_aM_y]
    type = MasterAnisotropyCartLLG
    variable = mag_y
    component = 1
  [../]
  [./d_aM_z]
    type = MasterAnisotropyCartLLG
    variable = mag_z
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #    demagnetization field              #
  #                                       #
  #---------------------------------------#

  [./d_HM_x]
    type = MasterInteractionCartLLG
    variable = mag_x
    component = 0
  [../]
  [./d_HM_y]
    type = MasterInteractionCartLLG
    variable = mag_y
    component = 1
  [../]
  [./d_HM_z]
    type = MasterInteractionCartLLG
    variable = mag_z
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #    Magnetostatic Poisson equation     #
  #                                       #
  #---------------------------------------#

  [./int_pot_lap]
    type = Electrostatics
    variable = potential_H_int
    block = &#x27;1 2&#x27;
  [../]
  [./int_bc_pot_lap]
    type = MagHStrongCart
    variable = potential_H_int
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #     LLB constraint terms              #
  #                                       #
  #---------------------------------------#

  [./llb_x]
    type = MasterLongitudinalLLB
    variable = mag_x
    component = 0
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
  [../]
  [./llb_y]
    type = MasterLongitudinalLLB
    variable = mag_y
    component = 1
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
  [../]

  [./llb_z]
    type = MasterLongitudinalLLB
    variable = mag_z
    component = 2
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
  [../]
[]

[BCs]
  #---------------------------------------#
  #                                       #
  #  ground the magnetostatic potential   #
  #  at boundaries of the bounding box    #
  #                                       #
  #---------------------------------------#

  [./bc_int_pot_boundary]
    type = DirichletBC
    variable = potential_H_int
    value = 0.0
    boundary = &#x27;1 2 3 4 5 6&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #  enforce Neumann condition (m*n = 0)  #
  #  at the boundary of the brick         #
  #                                       #
  #         Note: I don&#x27;t think this      #
  #               does anything but we    #
  #               leave it in regardless  #
  #                                       #
  #---------------------------------------#

  [./bc_surface_mag_x]
    type = NeumannBC
    variable = mag_x
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
  [./bc_surface_mag_y]
    type = NeumannBC
    variable = mag_y
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
  [./bc_surface_mag_z]
    type = NeumannBC
    variable = mag_z
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
[]

[Postprocessors]

  #---------------------------------------#
  #                                       #
  #       track dt step size              #
  #                                       #
  #---------------------------------------#

   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #       Average |M| and along other     #
  #       directions                      #
  #                                       #
  #---------------------------------------#

  [./&lt;M&gt;]
    type = ElementAverageValue
    variable = mag_s
    block = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;mx&gt;]
    type = ElementAverageValue
    variable = mag_x
    block = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;my&gt;]
    type = ElementAverageValue
    variable = mag_y
    block = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;mz&gt;]
    type = ElementAverageValue
    variable = mag_z
    block = &#x27;1&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate anisotropy energy of      #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fa]
    type = MasterMagneticAnisotropyEnergy
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
    energy_scale = 6241.51  #converts results to eV
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate exchange energy of        #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fexch]
    type = MasterMagneticExchangeEnergy
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
    energy_scale = 6241.51  #converts results to eV
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate demagnetization energy    #
  #   of the magnetic body                #
  #                                       #
  #---------------------------------------#

  [./Fdemag]
    type = MagnetostaticEnergyCart
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
    energy_scale = 6241.51  #converts results to eV
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate excess energy from missed #
  #   LLB targets                         #
  #                                       #
  #---------------------------------------#

  [./Fllb]
    type = MagneticExcessLLBEnergy
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
  [../]

  #---------------------------------------#
  #                                       #
  #   add all the energy contributions    #
  #   and calculate their percent change  #
  #                                       #
  #---------------------------------------#

  [./Ftot]
    type = LinearCombinationPostprocessor 
    pp_names = &#x27;Fexch Fdemag Fa&#x27;
    pp_coefs = &#x27; 1.0 1.0 1.0&#x27; 
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  [./perc_change]
    type = EnergyRatePostprocessor
    postprocessor = Ftot
    dt = dt 
    execute_on = &#x27;timestep_end final&#x27;
  [../]

[]


[UserObjects]
  [./kill]
    type = Terminator
    expression = &#x27;perc_change &lt;= 1.0e-5&#x27;
  [../]
[]

[Preconditioning]
  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type&#x27;
    petsc_options_value = &#x27;    121               1e-8      1e-8      1e-5      bjacobi&#x27;
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
  [./TimeIntegrator]
    type = ImplicitEuler
  [../]
  dtmin = 1e-12
  dtmax = 1.0e-2  #10 ns

  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 10
    linear_iteration_ratio = 100
    dt = 1.0e-8   #10 fs

  [../]

  verbose = true

  num_steps = 2
[]

[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = out_mag_brick
    elemental_as_nodal = true
    interval = 1
  [../]
  [./outCSV]
    type = CSV
    file_base = out_mag_brick
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c7c9c008-2542-49bc-92b4-a19ebfecd145"><div class="modal-content"><h4>(tutorial/AFMR_MnF2_ex.i)</h4><pre class="moose-pre"><code class="language-text">
##see J. Appl. Phys. 126, 151101 (2019);

Nx = 2
Ny = 2
Nz = 2

xMax = 0.01  # in micrometers = 10 nm
yMax = 0.01
zMax = 0.01


[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 3
    nx = ${Nx}
    ny = ${Ny}
    nz = ${Nz}
    xmin = 0.0
    xmax = ${xMax}
    ymin = 0.0
    ymax = ${yMax}
    zmin = 0.0
    zmax = ${zMax}
    elem_type = HEX8
  []
[]

[GlobalParams]
  mag1_x = mag1_x
  mag1_y = mag1_y
  mag1_z = mag1_z

  mag2_x = mag2_x
  mag2_y = mag2_y
  mag2_z = mag2_z
[]

[Materials]
  [./constants_kOe] # Constants used in other material properties
    type = GenericConstantMaterial
    prop_names = &#x27; H0         Ms        g0          He        Ha      &#x27;
    prop_values = &#x27;8.0e-5    1.0      2.8e9      0.000526     8.2e-6      &#x27;
  [../]
  [./constants] # Constants used in other material properties
    type = GenericConstantMaterial
    prop_names = &#x27; alpha     mu0   nx ny nz   long_susc t&#x27;
    prop_values = &#x27;0.0       1256   0  0  1          1.0     0&#x27;
  [../]

  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
  [../]
[]

[Functions]
  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;
    vars = &#x27;st&#x27;
    vals = &#x27;0.5&#x27;
  [../]
[]

[Variables]
  [./mag1_x]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag1_y]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0
      component  = 1
    [../]
  [../]
  [./mag1_z]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0
      component  = 2
    [../]
  [../]

  [./mag2_x]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0
      component  = 0
    [../]
  [../]
  [./mag2_y]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0
      component  = 1
    [../]
  [../]
  [./mag2_z]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0
      component  = 2
    [../]
  [../]

[]

[AuxVariables]

  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#

  [./azimuth_phi1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.3
      max = 0.35
      seed = 2
    [../]
  [../]
  [./polar_theta1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.0001
      max = 0.0002
      seed = 37
    [../]
  [../]

  [./azimuth_phi2]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.3
      max = 0.35
      seed = 2
    [../]
  [../]
  [./polar_theta2]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 3.1415
      max = 3.1416
      seed = 37
    [../]
  [../]

  [./mag1_s]
    order = FIRST
    family = LAGRANGE
  [../]
  [./mag2_s]
    order = FIRST
    family = LAGRANGE
  [../]

  [./Neel_L_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./Neel_L_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./Neel_L_z]
    order = FIRST
    family = LAGRANGE
  [../]

  [./SSMag_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./SSMag_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./SSMag_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag1_x_time]
    type = TimeDerivative
    variable = mag1_x
  [../]
  [./mag1_y_time]
    type = TimeDerivative
    variable = mag1_y
  [../]
  [./mag1_z_time]
    type = TimeDerivative
    variable = mag1_z
  [../]

  [./mag2_x_time]
    type = TimeDerivative
    variable = mag2_x
  [../]
  [./mag2_y_time]
    type = TimeDerivative
    variable = mag2_y
  [../]
  [./mag2_z_time]
    type = TimeDerivative
    variable = mag2_z
  [../]

  #---------------------------------------#
  #                                       #
  #     AFM resonance kernel terms        #
  #                                       #
  #---------------------------------------#

  [./afmr1_x]
    type = UniaxialAFMSublattice
    variable = mag1_x
    mag_sub = 0
    component = 0
  [../]
  [./afmr1_y]
    type = UniaxialAFMSublattice
    variable = mag1_y
    mag_sub = 0
    component = 1
  [../]
  [./afmr1_z]
    type = UniaxialAFMSublattice
    variable = mag1_z
    mag_sub = 0
    component = 2
  [../]

  [./afmr2_x]
    type = UniaxialAFMSublattice
    variable = mag2_x
    mag_sub = 1
    component = 0
  [../]
  [./afmr2_y]
    type = UniaxialAFMSublattice
    variable = mag2_y
    mag_sub = 1
    component = 1
  [../]
  [./afmr2_z]
    type = UniaxialAFMSublattice
    variable = mag2_z
    mag_sub = 1
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb1_x]
    type = LongitudinalLLB
    variable = mag1_x
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 0
  [../]
  [./llb1_y]
    type = LongitudinalLLB
    variable = mag1_y
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 1
  [../]

  [./llb1_z]
    type = LongitudinalLLB
    variable = mag1_z
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 2
  [../]

  [./llb2_x]
    type = LongitudinalLLB
    variable = mag2_x
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 0
  [../]
  [./llb2_y]
    type = LongitudinalLLB
    variable = mag2_y
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 1
  [../]

  [./llb2_z]
    type = LongitudinalLLB
    variable = mag2_z
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 2
  [../]
[]


[AuxKernels]
  [./mag1_mag]
    type = VectorMag
    variable = mag1_s
    vector_x = mag1_x
    vector_y = mag1_y
    vector_z = mag1_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./mag2_mag]
    type = VectorMag
    variable = mag2_s
    vector_x = mag2_x
    vector_y = mag2_y
    vector_z = mag2_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]


  [./Neel_Lx]
    type = VectorDiffOrSum
    variable = Neel_L_x
    var1 = mag1_x
    var2 = mag2_x
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./Neel_Ly]
    type = VectorDiffOrSum
    variable = Neel_L_y
    var1 = mag1_y
    var2 = mag2_y
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./Neel_Lz]
    type = VectorDiffOrSum
    variable = Neel_L_z
    var1 = mag1_z
    var2 = mag2_z
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./smallSignalMag_x]
    type = VectorDiffOrSum
    variable = SSMag_x
    var1 = mag1_x
    var2 = mag2_x
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./smallSignalMag_y]
    type = VectorDiffOrSum
    variable = SSMag_y
    var1 = mag1_y
    var2 = mag2_y
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./smallSignalMag_z]
    type = VectorDiffOrSum
    variable = SSMag_z
    var1 = mag1_z
    var2 = mag2_z
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

[]

[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag1_x_time]
    type = TimeDerivative
    variable = mag1_x
  [../]
  [./mag1_y_time]
    type = TimeDerivative
    variable = mag1_y
  [../]
  [./mag1_z_time]
    type = TimeDerivative
    variable = mag1_z
  [../]

  [./mag2_x_time]
    type = TimeDerivative
    variable = mag2_x
  [../]
  [./mag2_y_time]
    type = TimeDerivative
    variable = mag2_y
  [../]
  [./mag2_z_time]
    type = TimeDerivative
    variable = mag2_z
  [../]

  #---------------------------------------#
  #                                       #
  #     AFM resonance kernel terms        #
  #                                       #
  #---------------------------------------#

  [./afmr1_x]
    type = UniaxialAFMSublattice
    variable = mag1_x
    mag_sub = 0
    component = 0
  [../]
  [./afmr1_y]
    type = UniaxialAFMSublattice
    variable = mag1_y
    mag_sub = 0
    component = 1
  [../]
  [./afmr1_z]
    type = UniaxialAFMSublattice
    variable = mag1_z
    mag_sub = 0
    component = 2
  [../]

  [./afmr2_x]
    type = UniaxialAFMSublattice
    variable = mag2_x
    mag_sub = 1
    component = 0
  [../]
  [./afmr2_y]
    type = UniaxialAFMSublattice
    variable = mag2_y
    mag_sub = 1
    component = 1
  [../]
  [./afmr2_z]
    type = UniaxialAFMSublattice
    variable = mag2_z
    mag_sub = 1
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb1_x]
    type = LongitudinalLLB
    variable = mag1_x
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 0
  [../]
  [./llb1_y]
    type = LongitudinalLLB
    variable = mag1_y
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 1
  [../]

  [./llb1_z]
    type = LongitudinalLLB
    variable = mag1_z
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 2
  [../]

  [./llb2_x]
    type = LongitudinalLLB
    variable = mag2_x
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 0
  [../]
  [./llb2_y]
    type = LongitudinalLLB
    variable = mag2_y
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 1
  [../]

  [./llb2_z]
    type = LongitudinalLLB
    variable = mag2_z
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 2
  [../]
[]

[BCs]
  #---------------------------------------#
  #                                       #
  #  periodic magnetization distribution  #
  #                                       #
  #---------------------------------------#

  [./Periodic]
    [./xyz]
      auto_direction = &#x27;x y z&#x27;
      variable = &#x27;mag1_x mag1_y mag1_z mag2_x mag2_y mag2_z&#x27;
    [../]
  [../]
[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #       Average |M| and along other     #
  #       directions                      #
  #                                       #
  #---------------------------------------#

  [./&lt;M1&gt;]
    type = ElementAverageValue
    variable = mag1_s
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;M2&gt;]
    type = ElementAverageValue
    variable = mag2_s
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;m1x&gt;]
    type = ElementAverageValue
    variable = mag1_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m1y&gt;]
    type = ElementAverageValue
    variable = mag1_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m1z&gt;]
    type = ElementAverageValue
    variable = mag1_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;m2x&gt;]
    type = ElementAverageValue
    variable = mag2_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m2y&gt;]
    type = ElementAverageValue
    variable = mag2_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m2z&gt;]
    type = ElementAverageValue
    variable = mag2_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;Lx&gt;]
    type = ElementAverageValue
    variable = Neel_L_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;Ly&gt;]
    type = ElementAverageValue
    variable = Neel_L_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;Lz&gt;]
    type = ElementAverageValue
    variable = Neel_L_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;SSmx&gt;]
    type = ElementAverageValue
    variable = SSMag_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;SSmy&gt;]
    type = ElementAverageValue
    variable = SSMag_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;SSmz&gt;]
    type = ElementAverageValue
    variable = SSMag_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
[]


[Preconditioning]
  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_ksp_ew&#x27;
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type&#x27;
    petsc_options_value = &#x27;    121               1e-8      1e-6      1e-6      bjacobi&#x27;
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
  [./TimeIntegrator]
    type = NewmarkBeta
  [../]
  dtmin = 1e-11
  dtmax = 1.0e-3
  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 25
    iteration_window = 2000
    growth_factor = 1.3
    cutback_factor = 0.8
    dt = 12.0e-9
  [../]
  verbose = true

  num_steps = 18000
[]

[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = out_AFMR_ex
    elemental_as_nodal = true
    interval = 500
  [../]
  [./outCSV]
    type = CSV
    file_base = out_AFMR_ex
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1da862f7-17be-4cae-b5e2-c8cf2277e9e7"><div class="modal-content"><h4>(test/tests/magnets/slab_PML_small.i)</h4><pre class="moose-pre"><code class="language-text">
[GlobalParams]
  mag_x = mag_x
  mag_y = mag_y
  mag_z = mag_z

  potential_H_int = potential_H_int

  g0 = 1.0
  Hscale = 0.004519239
  mu0 = 1.256637e-06
  y0pmlminus = -25
  deltasyminus = 1.0e04
  deltawyminus = 5
  deltapyminus = 0.1
[]

alphadef = 0.02

[Mesh]
  [./mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 25
    ny = 43
    nz = 5
    xmin = -50
    xmax = 50
    ymin = -35
    ymax = 50
    zmin = -10
    zmax = 10
  [../]
  [./infinite_domain]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    bottom_left = &#x27;-50 -35 -10&#x27;
    top_right = &#x27;50 50 10&#x27;
    block_id = 3
    block_name = infinite_domain 
  [../]
  [./vacuum_box]
    type = SubdomainBoundingBoxGenerator
    input = infinite_domain
    bottom_left = &#x27;-50 -25 -10&#x27;
    top_right = &#x27;50 50 10&#x27;
    block_id = 2
    block_name = vacuum 
  [../]
  [./boundary1]
    type = SideSetsBetweenSubdomainsGenerator
    input = vacuum_box
    new_boundary = id_boundary
    paired_block = vacuum
    primary_block = 3 #mesh #infinite_domain
  [../]
  [./brick]
    type = SubdomainBoundingBoxGenerator
    input = boundary1 #vacuum_box
    bottom_left = &#x27;-10 -10 -1.5&#x27;
    top_right = &#x27;10 10 1.5&#x27;
    block_id = 1
    block_name = brick
  [../]
[../]



[Materials]
  ############################################################################
  ##
  ##       material constants used.
  ##
  ##
  ############################################################################

  [./constants] 
    type = GenericConstantMaterial
    prop_names = &#x27; alpha           permittivity  Ae        Ms&#x27;
    prop_values = &#x27;${alphadef}     1.0           1.3e-05   1.2&#x27;
    block = &#x27;1&#x27;
  [../]

#NOTE: g0 is g*mu0*Ms/2 as defined by Hertel 
#alpha is chosen to be 1.0 as in the muMag paper

 [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
    block = &#x27;1&#x27; 
 [../]
 [./constantsv]
    type = GenericConstantMaterial
    prop_names = &#x27; permittivity&#x27;
    prop_values = &#x27;1.0&#x27;
    block = &#x27;3 2&#x27;
  [../]
[]

[Functions]

  ##############################
  ##
  ## Define the ramping function
  ## expression to be used
  ##
  ##############################

  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;
    vars = &#x27;st&#x27;
    vals = &#x27;1.e1&#x27;  #3?
  [../]

[]

[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block= &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 2
    [../]
  [../]
  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
  [./phi2]
   order = FIRST
   family = LAGRANGE
   block = 3
  [../]
[]

[AuxVariables]

  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#

  [./azimuth_phi]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomIC
      min = 1.5708
      max = 1.5709
      seed = 2
    [../]
  [../]
  [./polar_theta]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomIC
      min = 1.5708
      max = 1.5709
      seed = 37
    [../]
  [../]

  [./mag_s]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]
  [./H_y]
    order = FIRST
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
  [./H_y_v]
    order = FIRST
    family = MONOMIAL
    block = &#x27;3&#x27;
  [../]
[]


[AuxKernels]
  [./mag_mag]
    type = VectorMag
    variable = mag_s
    vector_x = mag_x
    vector_y = mag_y
    vector_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./Hy_brick]
    type = DemagFieldAux
    variable = H_y
    component = 1
    block = &#x27;1 2&#x27;
  [../]
  [./Hy_id]
    type = DemagFieldAuxPML
    phi1 = phi2
    variable = H_y_v
    component = 1
    block = &#x27;3&#x27;
  [../]
[]


[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag_x_time]
    type = TimeDerivative
    variable = mag_x
    block = &#x27;1&#x27;
  [../]
  [./mag_y_time]
    type = TimeDerivative
    variable = mag_y
    block = &#x27;1&#x27;
  [../]
  [./mag_z_time]
    type = TimeDerivative
    variable = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    Local magnetic exchange            #
  #                                       #
  #---------------------------------------#
  
  [./dllg_x_exch]
    type = MasterExchangeCartLLG
    variable = mag_x
    component = 0
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]
  [./dllg_y_exch]
    type = MasterExchangeCartLLG
    variable = mag_y
    component = 1
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]
  [./dllg_z_exch]
    type = MasterExchangeCartLLG
    variable = mag_z
    component = 2
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    demagnetization field              #
  #                                       #
  #---------------------------------------#

  [./d_HM_x]
    type = MasterInteractionCartLLG
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./d_HM_y]
    type = MasterInteractionCartLLG
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]
  [./d_HM_z]
    type = MasterInteractionCartLLG
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb1_x]
    type = MasterLongitudinalLLB
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./llb1_y]
    type = MasterLongitudinalLLB
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]

  [./llb1_z]
    type = MasterLongitudinalLLB
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    Magnetostatic Poisson equation     #
  #                                       #
  #---------------------------------------#

  [./int_pot_lap]
    type = Electrostatics
    variable = potential_H_int
    block = &#x27;1 2&#x27;
  [../]
  [./int_bc_pot_lap]
    type = MagHStrongCart
    variable = potential_H_int
    block = &#x27;1&#x27;
  [../]
  [./infinite_domain]
    type = MagneticPMLCart
    variable = phi2
    component = 1
    block = &#x27;3&#x27;
  [../]    

[]

[InterfaceKernels]
  [./PML_boundary]
    type = InterfaceEquality
    variable = potential_H_int
    boundary = id_boundary
    neighbor_var = potential_H_int
    permittivity_neighbor = 1.
  [../]
[]

[BCs]
  [./vacuum_box]
    type = DirichletBC
    variable = phi2
    value = 0.
    boundary = &#x27;bottom&#x27;
  [../]
  [./other_boundaries]
    type = DirichletBC
    variable = potential_H_int
    value = 0.
    boundary = &#x27;left right front back top &#x27;
  [../]
  [./boundarydirichlet]
    type = CoupledDirichletBC
    variable = phi2
    coupled_var = potential_H_int
    boundary = id_boundary
  []    
[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #     Average M = |m|                   #
  #                                       #
  #---------------------------------------#

  [./M1]
    type = ElementAverageValue
    variable = mag_s
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  [./&lt;mx&gt;]
    type = ElementAverageValue
    variable = mag_x
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;my&gt;]
    type = ElementAverageValue
    variable = mag_y
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;mz&gt;]
    type = ElementAverageValue
    variable = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate exchange energy of        #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fexch]
    type = MasterMagneticExchangeEnergy
    energy_scale = 0.001  #converts results to eV
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate demagnetization energy    #
  #   of the magnetic body                #
  #                                       #
  #---------------------------------------#

  [./Fdemag]
    type = MagnetostaticEnergyCart
    energy_scale = 0.001  #converts results to eV
    execute_on = &#x27;initial timestep_begin timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]


  #---------------------------------------#
  #                                       #
  #   Calculate excess energy from missed #
  #   LLB targets                         #
  #                                       #
  #---------------------------------------#

  [./Fllb1]
    type = MagneticExcessLLBEnergy
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   add all the energy contributions    #
  #   and calculate their percent change  #
  #                                       #
  #---------------------------------------#

  [./Ftot]
    type = LinearCombinationPostprocessor 
    pp_names = &#x27;Fexch Fdemag&#x27;
    pp_coefs = &#x27; 1.0 1.0&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./perc_change]
    type = EnergyRatePostprocessor
    postprocessor = Ftot
    dt = dt 
    execute_on = &#x27;timestep_end final&#x27;
  [../]
[]

[UserObjects]
  [./kill]
    type = Terminator
    expression = &#x27;perc_change &lt;= 1.0e-8&#x27;
  [../]
[]

    
[Preconditioning]

  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP #FDP
#     petsc_options_iname = &#x27; -pc_type -mat_fd_coloring_err -mat_fd_type&#x27;
#     petsc_options_value = &#x27;lu   1.e-06   ds&#x27;
    full = true
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type -sub_pc_type &#x27;
    petsc_options_value = &#x27;    100               1e-12      1e-9      1e-8     bjacobi   ilu&#x27;
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
  automatic_scaling = true

  [./TimeIntegrator]
    type = NewmarkBeta
  [../]

  dtmin = 1.e-5
  dtmax = 1.e-3
  end_time = 2

  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 25  #usually 10
    linear_iteration_ratio = 100
    dt = 1e-4
    growth_factor = 1.1
    cutback_factor = 0.75
  [../]
  num_steps = 2
[../]



[Outputs]
  print_linear_residuals = false
  [pgraph]
  type = PerfGraphOutput
  execute_on = final
  level = 2
[] 
  [./out]
    type = Exodus
    file_base = slab_PML_small_25_002
    elemental_as_nodal = true
    interval = 1
    execute_on = &#x27;initial timestep_end&#x27;
  [../]
  [./outCSV]
    type = CSV
    file_base = slab_PML_small_25_002
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="0ac4fdea-aab7-4278-8a1a-f76ccc713ccd"><div class="modal-content"><h4>(tutorial/ringdown.i)</h4><pre class="moose-pre"><code class="language-text">[GlobalParams]
  mag_x = mag_x
  mag_y = mag_y
  mag_z = mag_z

  potential_H_int = potential_H_int

  g0 = 1.0
  Hscale = 0.004519239
  mu0 = 1.256637e-06
[]

alphadef = 0.02

[Mesh]
  [./mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 50
    ny = 50
    nz = 10
    xmin = -50
    xmax = 50
    ymin = -50
    ymax = 50
    zmin = -10
    zmax = 10
  [../]  
  [./vacuum_box]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    bottom_left = &#x27;-50 -50 -10&#x27;
    top_right = &#x27;50 50 10&#x27;
    block_id = 2
    block_name = vacuum 
  [../]
  [./brick]
    type = SubdomainBoundingBoxGenerator
    input = vacuum_box
    bottom_left = &#x27;-10 -10 -1.5&#x27;
    top_right = &#x27;10 10 1.5&#x27;
    block_id = 1
    block_name = brick
  [../]
[../]



[Materials]
  ############################################################################
  ##
  ##       material constants used.
  ##
  ############################################################################

  [./constants] 
    type = GenericConstantMaterial
    prop_names = &#x27; alpha           permittivity  Ae        Ms&#x27;
    prop_values = &#x27;${alphadef}     1.0           1.3e-05   1.2&#x27;
    block = &#x27;1&#x27;
  [../]

  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
    block = &#x27;1&#x27; 
  [../]
  [./constantsv]
    type = GenericConstantMaterial
    prop_names = &#x27; alpha     permittivity Ae      Ms&#x27;
    prop_values = &#x27;1         1.0        1.3e-05   .0&#x27;
    block = &#x27;2&#x27;
  [../]
  [./a_longv]
    type = GenericFunctionMaterial
     prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
    block = &#x27;2&#x27;
  [../]

[]

[Functions]
  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;
    vars = &#x27;st&#x27;
    vals = &#x27;1.e1&#x27;  #3?
  [../]
[]

[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block= &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0
      component  = 2
    [../]
  [../]

  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxVariables]
  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#
  [./azimuth_phi]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.
      max = 0.01
      seed = 2
    [../]
  [../]
  [./polar_theta]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 1.5708
      max = 1.5709
      seed = 37
    [../]
  [../]

  [./mag_s]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag_x_time]
    type = TimeDerivative
    variable = mag_x
    block = &#x27;1&#x27;
  [../]
  [./mag_y_time]
    type = TimeDerivative
    variable = mag_y
    block = &#x27;1&#x27;
  [../]
  [./mag_z_time]
    type = TimeDerivative
    variable = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    Local magnetic exchange            #
  #                                       #
  #---------------------------------------#
  
  [./dllg_x_exch]
    type = MasterExchangeCartLLG
    variable = mag_x
    component = 0
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]
  [./dllg_y_exch]
    type = MasterExchangeCartLLG
    variable = mag_y
    component = 1
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]
  [./dllg_z_exch]
    type = MasterExchangeCartLLG
    variable = mag_z
    component = 2
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    demagnetization field              #
  #                                       #
  #---------------------------------------#

  [./d_HM_x]
    type = MasterInteractionCartLLG
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./d_HM_y]
    type = MasterInteractionCartLLG
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]
  [./d_HM_z]
    type = MasterInteractionCartLLG
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb1_x]
    type = MasterLongitudinalLLB
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./llb1_y]
    type = MasterLongitudinalLLB
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]

  [./llb1_z]
    type = MasterLongitudinalLLB
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    Magnetostatic Poisson equation     #
  #                                       #
  #---------------------------------------#

  [./int_pot_lap]
    type = Electrostatics
    variable = potential_H_int
    block = &#x27;1 2&#x27;
  [../]
  [./int_bc_pot_lap]
    type = MagHStrongCart
    variable = potential_H_int
    block = &#x27;1&#x27;
  [../]

[]

[BCs]
  [./vacuum_box]
    type = DirichletBC
    value = 0.
    variable = potential_H_int
    boundary = &#x27;0 1 2 3 4 5&#x27;
  [../]
[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #     Average M = |m|                   #
  #                                       #
  #---------------------------------------#

  [./M1]
    type = ElementAverageValue
    variable = mag_s
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  [./&lt;mx&gt;]
    type = ElementAverageValue
    variable = mag_x
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;my&gt;]
    type = ElementAverageValue
    variable = mag_y
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;mz&gt;]
    type = ElementAverageValue
    variable = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate exchange energy of        #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fexch]
    type = MasterMagneticExchangeEnergy
    energy_scale = 0.001  #converts results to eV
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate demagnetization energy    #
  #   of the magnetic body                #
  #                                       #
  #---------------------------------------#

  [./Fdemag]
    type = MagnetostaticEnergyCart
    energy_scale = 0.001  #converts results to eV
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate excess energy from missed #
  #   LLB targets                         #
  #                                       #
  #---------------------------------------#

  [./Fllb1]
    type = MagneticExcessLLBEnergy
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   add all the energy contributions    #
  #   and calculate their percent change  #
  #                                       #
  #---------------------------------------#

  [./Ftot]
    type = LinearCombinationPostprocessor 
    pp_names = &#x27;Fexch Fdemag&#x27;
    pp_coefs = &#x27; 1.0 1.0&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./perc_change]
    type = EnergyRatePostprocessor
    postprocessor = Ftot
    dt = dt 
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  [./elapsed]
    type = PerfGraphData
    section_name = &quot;Root&quot;  # for profiling the problem
    data_type = total
  [../]
[]

[AuxKernels]
  [./mag_mag]
    type = VectorMag
    variable = mag_s
    vector_x = mag_x
    vector_y = mag_y
    vector_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
[]

[UserObjects]
  [./kill]
    type = Terminator
    expression = &#x27;perc_change &lt;= 1.0e-6&#x27;
  [../]
[]

[Preconditioning]

  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type &#x27;
    petsc_options_value = &#x27;    100               1e-12      1e-9      1e-8     bjacobi&#x27;
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;

  [./TimeIntegrator]
    type = NewmarkBeta
  [../]

  dtmin = 1.e-4
  dtmax = 5.e-3
  end_time = 10.0

  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 25  #usually 10
    linear_iteration_ratio = 100
    dt = 1e-6
    growth_factor = 1.1
    cutback_factor = 0.75
  [../]
  num_steps = 12000
[../]



[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = out_ringdown
    elemental_as_nodal = true
    interval = 10
  [../]
  [./outCSV]
    type = CSV
    file_base = out_ringdown
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="54f0fb1f-d00f-4838-a615-78348a565844"><div class="modal-content"><h4>(test/tests/magnets/magnetostatic_brick.i)</h4><pre class="moose-pre"><code class="language-text">
[Mesh]
  [./fmg]
    type = FileMeshGenerator
    file = exodus_pysq_dx1_AnoI.e
  []

  [central_interface]
    type = SideSetsBetweenSubdomainsGenerator
    input = fmg
    master_block = &#x27;1&#x27;
    paired_block = &#x27;2&#x27;
    primary_block = &#x27;1&#x27;
    new_boundary = &#x27;70&#x27;
  []
[]


[GlobalParams]
  mag_x = mag_x
  mag_y = mag_y
  mag_z = mag_z
  potential_H_int = potential_H_int
[]

[Materials]
  [./constants] # Constants used in other material properties
    type = GenericConstantMaterial
    prop_names = &#x27; alpha    Ae    Ms    g0     mu0   nx ny nz   long_susc t&#x27;
    prop_values = &#x27;0.01    0.013  1.2  221010.0 1256.64   1  0  0          1.0     0&#x27;
  [../]
  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
  [../]
  [./permitivitty_1]
    type = GenericConstantMaterial
    prop_names = &#x27;permittivity&#x27;  #dummy variable at the moment since we use the &quot;electrostatics&quot; kernel
    prop_values = &#x27;1.0&#x27;
    block = &#x27;1 2&#x27;
  [../]
[]

[Functions]

  ##############################
  ##
  ## Define the ramping function
  ## expression to be used
  ##
  ##############################

  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;   #*tanh(sl*t)+1.0&#x27;
    vars = &#x27;st&#x27; #sl&#x27;
    vals = &#x27;100.0&#x27; # 795.775&#x27;
  [../]
[]

[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 2
    [../]
  [../]

  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxVariables]
  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#
  [./azimuth_phi]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomIC
      min = 0.001
      max = 0.002
      seed = 2
    [../]
  [../]
  [./polar_theta]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomIC
      min = 1.5707
      max = 1.5708
      seed = 37
    [../]
  [../]

  [./mag_s]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
  [../]

  [./H_x]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
  [./H_y]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
  [./H_z]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxKernels]
  [./mag_mag]
    type = VectorMag
    variable = mag_s
    vector_x = mag_x
    vector_y = mag_y
    vector_z = mag_z
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  [./hxo]
    type = DemagFieldAux
    component = 0
    variable = H_x
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./hyo]
    type = DemagFieldAux
    component = 1
    variable = H_y
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./hzo]
    type = DemagFieldAux
    component = 2
    variable = H_z
    block = &#x27;1 2&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
[]

[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag_x_time]
    type = TimeDerivative
    variable = mag_x
    block = &#x27;1&#x27;
  [../]
  [./mag_y_time]
    type = TimeDerivative
    variable = mag_y
    block = &#x27;1&#x27;
  [../]
  [./mag_z_time]
    type = TimeDerivative
    variable = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #          Magnetic exchange            #
  #                                       #
  #---------------------------------------#

  [./dllg_x_exch]
    type = ExchangeCartLL
    variable = mag_x
    component = 0
  [../]
  [./dllg_y_exch]
    type = ExchangeCartLL
    variable = mag_y
    component = 1
  [../]
  [./dllg_z_exch]
    type = ExchangeCartLL
    variable = mag_z
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #         demagnetization field         #
  #                                       #
  #---------------------------------------#

  [./d_HM_x]
    type = InteractionCartLL
    variable = mag_x
    component = 0
  [../]
  [./d_HM_y]
    type = InteractionCartLL
    variable = mag_y
    component = 1
  [../]
  [./d_HM_z]
    type = InteractionCartLL
    variable = mag_z
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #    Magnetostatic Poisson equation     #
  #                                       #
  #---------------------------------------#

  [./int_pot_lap]
    type = Electrostatics
    variable = potential_H_int
    block = &#x27;1 2&#x27;
  [../]
  [./int_bc_pot_lap]
    type = MagHStrongCart
    variable = potential_H_int
    block = &#x27;1&#x27;
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb_x]
    type = LongitudinalLLB
    variable = mag_x
    component = 0
  [../]
  [./llb_y]
    type = LongitudinalLLB
    variable = mag_y
    component = 1
  [../]

  [./llb_z]
    type = LongitudinalLLB
    variable = mag_z
    component = 2
  [../]
[]

[BCs]
  #---------------------------------------#
  #                                       #
  #  ground the magnetostatic potential   #
  #  at two boundaries                    #
  #                                       #
  #---------------------------------------#

  [./bc_int_pot_boundary]
    type = DirichletBC
    variable = potential_H_int
    value = 0.0
    boundary = &#x27;1 2 3 4 5 6&#x27;
  [../]

  [./bc_surface_mag_x]
    type = NeumannBC
    variable = mag_x
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
  [./bc_surface_mag_y]
    type = NeumannBC
    variable = mag_y
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
  [./bc_surface_mag_z]
    type = NeumannBC
    variable = mag_z
    value = 0.0
    boundary = &#x27;70&#x27;
  [../]
[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #       Average |M| and along other     #
  #       directions                      #
  #                                       #
  #---------------------------------------#

  [./&lt;M&gt;]
    type = ElementAverageValue
    variable = mag_s
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  [./&lt;mx&gt;]
    type = ElementAverageValue
    variable = mag_x
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./&lt;my&gt;]
    type = ElementAverageValue
    variable = mag_y
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]
  [./&lt;mz&gt;]
    type = ElementAverageValue
    variable = mag_z
    block = &#x27;1&#x27;
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate exchange energy of        #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fexch]
    type = MagneticExchangeEnergy
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate demagnetization energy    #
  #   of the magnetic body                #
  #                                       #
  #---------------------------------------#

  [./Fdemag]
    type = MagnetostaticEnergyCart
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate excess energy from missed #
  #   LLB targets                         #
  #                                       #
  #---------------------------------------#

  [./Fllb]
    type = MagneticExcessLLBEnergy
    execute_on = &#x27;timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]


  #---------------------------------------#
  #                                       #
  #   add all the energy contributions    #
  #   and calculate their percent change  #
  #                                       #
  #---------------------------------------#

  [./Ftot]
    type = LinearCombinationPostprocessor 
    pp_names = &#x27;Fexch Fdemag Fllb&#x27;
    pp_coefs = &#x27; 1.0 1.0 1.0&#x27; 
    execute_on = &#x27;timestep_end final&#x27;
  [../]

  [./perc_change]
    type = EnergyRatePostprocessor
    postprocessor = Ftot
    dt = dt 
    execute_on = &#x27;timestep_end final&#x27;
  [../]
[]


[UserObjects]
  [./kill]
    type = Terminator
    expression = &#x27;perc_change &lt;= 1.0e-5&#x27;
  [../]
[]



[Preconditioning]
  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_ksp_ew -snes_converged_reason&#x27;
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type&#x27;
    petsc_options_value = &#x27;    121               1e-10      1e-8      1e-6      bjacobi&#x27;
  [../]
[]

#[Debug]
#   show_var_residual_norms = true
#[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
  [./TimeIntegrator]
    type = ImplicitEuler
  [../]
  dtmin = 1e-9
  dtmax = 1.0e-5
  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 18
    growth_factor = 1.3
    cutback_factor = 0.8
    dt = 1.0e-8
  [../]
  verbose = true
  num_steps = 2
[]

[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = out_magnetostatic_brick
    elemental_as_nodal = true
    interval = 1
  [../]
  [./outCSV]
    type = CSV
    file_base = out_magnetostatic_brick
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="587f9394-f056-4032-b606-6cb59a27b7bc"><div class="modal-content"><h4>(test/tests/magnets/ringdown.i)</h4><pre class="moose-pre"><code class="language-text">

  ##############################
  ##
  ## UNITS:
  ##    
  ##   gamma = (2.2101*10^5 ) m/C
  ##
  ## NOTE:
  ##   gamma*Hscale = 1/ns
  ##
  ##   coefficients given in (pg/nm*ns) 
  ##   which is equivalent to an energy/vol
  ##
  ##   Effective fields are 1/(mu0*Ms)*coeff
  ##   which gives units of aC/(nm*mus)
  ##
  ##   Energies are natively printed in units 
  ##    of 0.160218 pg nm^2 / mus^2 
  ##    or 1.60218*10^{-22} J
  ##    or 0.001 eV
  ##
  ##############################

################
#
#  LLG alpha:
#
################

alphadef = 0.02


[Mesh]
  [./mesh]
    type = GeneratedMeshGenerator
    dim = 3
    nx = 50
    ny = 50
    nz = 10
    xmin = -50
    xmax = 50
    ymin = -50
    ymax = 50
    zmin = -10
    zmax = 10
  [../]  
  [./vacuum_box]
    type = SubdomainBoundingBoxGenerator
    input = mesh
    bottom_left = &#x27;-50 -50 -10&#x27;
    top_right = &#x27;50 50 10&#x27;
    block_id = 2
    block_name = vacuum 
  [../]
  [./brick]
    type = SubdomainBoundingBoxGenerator
    input = vacuum_box
    bottom_left = &#x27;-10 -10 -1.5&#x27;
    top_right = &#x27;10 10 1.5&#x27;
    block_id = 1
    block_name = brick
  [../]
[../]


[GlobalParams]
  mag_x = mag_x
  mag_y = mag_y
  mag_z = mag_z

  potential_H_int = potential_H_int
    
  Hscale = 0.004519239
  g0 = 1.0
  mu0 = 1.256637e-06

[]

[Materials]
  ############################################################################
  ##
  ##       material constants used.
  ##
  ############################################################################

  [./constants] 
    type = GenericConstantMaterial
    prop_names = &#x27; alpha                 Ae      Ms   permittivity&#x27;
    prop_values = &#x27;${alphadef}          1.3e-05  1.2  1.&#x27;
    block = &#x27;1&#x27;
  [../]

  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
    block = &#x27;1&#x27; 
  [../]
 [./constantsv]
    type = GenericConstantMaterial
    prop_names = &#x27; alpha                Ae      Ms  permittivity&#x27;
    prop_values = &#x27;1                   1.e-05   0.  1. &#x27;
    block = &#x27;2&#x27;
  [../]
  [./a_longv]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
    block = &#x27;2&#x27;
  [../]

[]

[Functions]

  ##############################
  ##
  ## Define the ramping function
  ## expression to be used
  ##
  ##############################

  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;
    vars = &#x27;st&#x27;
    vals = &#x27;1.e3&#x27;  #3?
  [../]
[]

[Variables]
  [./mag_x]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag_y]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 1
    [../]
  [../]
  [./mag_z]
    order = FIRST
    family = LAGRANGE
    block= &#x27;1&#x27;
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi
      theta = polar_theta
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 2
    [../]
  [../]

  [./potential_H_int]
    order = FIRST
    family = LAGRANGE
    block = &#x27;1 2&#x27;
  [../]
[]

[AuxVariables]
  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#
  [./azimuth_phi]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.
      max = 0.01
      seed = 2
    [../]
  [../]
  [./polar_theta]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 1.5708
      max = 1.5709
      seed = 37
    [../]
  [../]

  [./mag_s]
    order = FIRST
    family = LAGRANGE
  [../]

  [./H_x]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 1.0
    [../]
  [../]
  [./H_y]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 1.0
    [../]
  [../]
  [./H_z]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = ConstantIC
      value = 1.0
    [../]
  [../]
[]


[AuxKernels]
  [./mag_mag]
    type = VectorMag
    variable = mag_s
    vector_x = mag_x
    vector_y = mag_y
    vector_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
[]


[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag_x_time]
    type = TimeDerivative
    variable = mag_x
    block = &#x27;1&#x27;
  [../]
  [./mag_y_time]
    type = TimeDerivative
    variable = mag_y
    block = &#x27;1&#x27;
  [../]
  [./mag_z_time]
    type = TimeDerivative
    variable = mag_z
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    Local magnetic exchange            #
  #                                       #
  #---------------------------------------#
  
  [./dllg_x_exch]
    type = MasterExchangeCartLLG
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./dllg_y_exch]
    type = MasterExchangeCartLLG
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]
  [./dllg_z_exch]
    type = MasterExchangeCartLLG
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #    demagnetization field              #
  #                                       #
  #---------------------------------------#

  [./d_HM_x]
    type = MasterInteractionCartLLG
    variable = mag_x
    component = 0
    block = &#x27;1&#x27;
  [../]
  [./d_HM_y]
    type = MasterInteractionCartLLG
    variable = mag_y
    component = 1
    block = &#x27;1&#x27;
  [../]
  [./d_HM_z]
    type = MasterInteractionCartLLG
    variable = mag_z
    component = 2
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

#  [./llb1_x]
#    type = MasterLongitudinalLLB
#    variable = mag_x
#    component = 0
#    block = &#x27;1&#x27;
#  [../]
#  [./llb1_y]
#    type = MasterLongitudinalLLB
#    variable = mag_y
#    component = 1
#    block = &#x27;1&#x27;
#  [../]
#
#  [./llb1_z]
#    type = MasterLongitudinalLLB
#    variable = mag_z
#    component = 2
#    block = &#x27;1&#x27;
#  [../]

  #---------------------------------------#
  #                                       #
  #    Magnetostatic Poisson equation     #
  #                                       #
  #---------------------------------------#

  [./int_pot_lap]
    type = Electrostatics
    variable = potential_H_int
    block = &#x27;1 2&#x27;
  [../]
  [./int_bc_pot_lap]
    type = MagHStrongCart
    variable = potential_H_int
    block = &#x27;1&#x27;
  [../]

[]

[BCs]
  [./vacuum_box]
    type = DirichletBC
    value = 0.
    variable = potential_H_int
    boundary = &#x27;0 1 2 3 4 5&#x27;
  [../]
[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #     Average M = |m|                   #
  #                                       #
  #---------------------------------------#

  [./M1]
    type = ElementAverageValue
    variable = mag_s
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  [./&lt;mx&gt;]
    type = ElementAverageValue
    variable = mag_x
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;my&gt;]
    type = ElementAverageValue
    variable = mag_y
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]
  [./&lt;mz&gt;]
    type = ElementAverageValue
    variable = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate exchange energy of        #
  #   the magnetic body                   #
  #                                       #
  #---------------------------------------#

  [./Fexch]
    type = MasterMagneticExchangeEnergy
    energy_scale = 1.  #converts results to eV
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   Calculate demagnetization energy    #
  #   of the magnetic body                #
  #                                       #
  #---------------------------------------#

  [./Fdemag]
    type = MagnetostaticEnergyCart
    energy_scale = 1.  #converts results to eV
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]


  #---------------------------------------#
  #                                       #
  #   Calculate excess energy from missed #
  #   LLB targets                         #
  #                                       #
  #---------------------------------------#

  [./Fllb1]
    type = MagneticExcessLLBEnergy
    mag_x = mag_x
    mag_y = mag_y
    mag_z = mag_z
    execute_on = &#x27;initial timestep_end final&#x27;
    block = &#x27;1&#x27;
  [../]

  #---------------------------------------#
  #                                       #
  #   add all the energy contributions    #
  #   and calculate their percent change  #
  #                                       #
  #---------------------------------------#

  [./Ftot]
    type = LinearCombinationPostprocessor 
    pp_names = &#x27;Fexch Fdemag&#x27;
    pp_coefs = &#x27; 1.0 1.0&#x27;
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./perc_change]
    type = EnergyRatePostprocessor
    postprocessor = Ftot
    dt = dt 
    execute_on = &#x27;timestep_end final&#x27;
  [../]
[]

[UserObjects]
  [./kill]
    type = Terminator
    expression = &#x27;perc_change &lt;= 1.0e-8&#x27;
  [../]
  [mag]
    type = RenormalizeVector
    v = &#x27;mag_x mag_y mag_z&#x27;
    norm = 1
    execute_on = &#x27;TIMESTEP_END&#x27;
#    force_praux = true
  []
[]

[Preconditioning]
    active = smp
 [./muPBP]
    type = PBP
    solve_order = &#x27;mag_x mag_y mag_z potential_H_int&#x27;
    preconditioner = &#x27;AMG ILU&#x27;
    off_diag_row = &#x27;mag_x mag_y mag_z&#x27;
    off_diag_column = &#x27;mag_x mag_y mag_z&#x27;
 [../]
 [./muFSP]
    type = FSP
    topsplit = &#x27;magpot&#x27;
    [./magpot]
      splitting = &#x27;mag pot&#x27;
      splitting_type = additive
    [../]
    [./mag]
      vars = &#x27;mag_x mag_y mag_z&#x27;
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type -pc_sub_type &#x27;
    petsc_options_value = &#x27;    40               1e-20      1e-6      1e-6     bjacobi  ilu&#x27;
    [../]
    [./pot]
      vars = potential_H_int
      petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type -pc_sub_type &#x27;
      petsc_options_value = &#x27;    40               1e-12      1e-6      1e-6     bjacobi ilu&#x27;
    [../]
  [../]

  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type&#x27;
    petsc_options_value = &#x27;    40               1e-8      1e-8      1e-4      bjacobi&#x27; 
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
#  num_grids = 8

  [./TimeIntegrator]
    type = NewmarkBeta #LStableDirk4 #NewmarkBeta
  [../]

  dtmin = 1.e-5
  dtmax = 2.e-3
  end_time = 5.
  automatic_scaling = true

  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 15  #usually 10
    iteration_window = 2
    linear_iteration_ratio = 1000
    dt = 1.e-4
    growth_factor = 1.1
    cutback_factor = 0.75
  [../]
  num_steps = 20
[../]



[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = ringdown
    elemental_as_nodal = true
    interval = 10
  [../]
  [./outCSV]
    type = CSV
    file_base = ringdown
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6ac908b3-882f-45b7-adf7-14547e54d970"><div class="modal-content"><h4>(test/tests/magnets/AFMR_MnF2_ex.i)</h4><pre class="moose-pre"><code class="language-text">
##see J. Appl. Phys. 126, 151101 (2019);


Nx = 2
Ny = 2
Nz = 2

xMax = 0.01  # = 10 nm
yMax = 0.01
zMax = 0.01


[Mesh]
  [gen]
    type = GeneratedMeshGenerator
    dim = 3
    nx = ${Nx}
    ny = ${Ny}
    nz = ${Nz}
    xmin = 0.0
    xmax = ${xMax}
    ymin = 0.0
    ymax = ${yMax}
    zmin = 0.0
    zmax = ${zMax}
    elem_type = HEX8
  []
  [./cnode]
    input = gen

    ############################################
    ##
    ##   additional boundary sideset (one node) 
    ##   to zero one of the elastic displacement vectors 
    ##   vectors and eliminates rigid body translations 
    ##   from the degrees of freedom
    ##
    ##   NOTE: This must conform with the about
    ##         [Mesh] block settings
    ##
    ############################################

    type = ExtraNodesetGenerator
    coord = &#x27;0.0 0.0 0.0&#x27;
    new_boundary = 100
  [../]
[]

[GlobalParams]
  mag1_x = mag1_x
  mag1_y = mag1_y
  mag1_z = mag1_z

  mag2_x = mag2_x
  mag2_y = mag2_y
  mag2_z = mag2_z
[]

[Materials]
  [./constants_kOe] # Constants used in other material properties
    type = GenericConstantMaterial
    prop_names = &#x27; H0         Ms        g0          He        Ha      &#x27;
    prop_values = &#x27;8.0e-5    1.0      2.8e9      0.000526     8.2e-6      &#x27;
  [../]


  [./constants] # Constants used in other material properties
    type = GenericConstantMaterial
    prop_names = &#x27; alpha     mu0   nx ny nz   long_susc t&#x27;
    prop_values = &#x27;0.0       1256   0  0  1          1.0     0&#x27;
  [../]

  [./a_long]
    type = GenericFunctionMaterial
    prop_names = &#x27;alpha_long&#x27;
    prop_values = &#x27;bc_func_1&#x27;
  [../]
[]

[Functions]

  ##############################
  ##
  ## Define the ramping function
  ## expression to be used
  ##
  ##############################

  [./bc_func_1]
    type = ParsedFunction
    value = &#x27;st&#x27;   #*tanh(sl*t)+1.0&#x27;
    vars = &#x27;st&#x27; #sl&#x27;
    vals = &#x27;0.5&#x27; # 795.775&#x27;
  [../]
[]

[Variables]
  [./mag1_x]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag1_y]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 1
    [../]
  [../]
  [./mag1_z]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi1
      theta = polar_theta1
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 2
    [../]
  [../]

  [./mag2_x]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 0
    [../]
  [../]
  [./mag2_y]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 1
    [../]
  [../]
  [./mag2_z]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomConstrainedVectorFieldIC
      phi = azimuth_phi2
      theta = polar_theta2
      M0s = 1.0 #amplitude of the RandomConstrainedVectorFieldIC
      component  = 2
    [../]
  [../]

[]

[AuxVariables]
  #--------------------------------------------#
  #                                            #
  #  field to seed IC that obeys constraint    #
  #                                            #
  #--------------------------------------------#
  [./azimuth_phi1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.3
      max = 0.35
      seed = 2
    [../]
  [../]
  [./polar_theta1]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.2
      max = 0.21
      seed = 37
    [../]
  [../]

  [./azimuth_phi2]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 0.3
      max = 0.35
      seed = 2
    [../]
  [../]
  [./polar_theta2]
    order = FIRST
    family = LAGRANGE
    [./InitialCondition]
      type = RandomIC
      min = 2.92
      max = 2.93
      seed = 37
    [../]
  [../]

  [./mag1_s]
    order = FIRST
    family = LAGRANGE
  [../]
  [./mag2_s]
    order = FIRST
    family = LAGRANGE
  [../]

  [./Neel_L_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./Neel_L_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./Neel_L_z]
    order = FIRST
    family = LAGRANGE
  [../]


  [./SSMag_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./SSMag_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./SSMag_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxKernels]
  [./mag1_mag]
    type = VectorMag
    variable = mag1_s
    vector_x = mag1_x
    vector_y = mag1_y
    vector_z = mag1_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./mag2_mag]
    type = VectorMag
    variable = mag2_s
    vector_x = mag2_x
    vector_y = mag2_y
    vector_z = mag2_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]


  [./Neel_Lx]
    type = VectorDiffOrSum
    variable = Neel_L_x
    var1 = mag1_x
    var2 = mag2_x
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./Neel_Ly]
    type = VectorDiffOrSum
    variable = Neel_L_y
    var1 = mag1_y
    var2 = mag2_y
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./Neel_Lz]
    type = VectorDiffOrSum
    variable = Neel_L_z
    var1 = mag1_z
    var2 = mag2_z
    diffOrSum = 0
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./smallSignalMag_x]
    type = VectorDiffOrSum
    variable = SSMag_x
    var1 = mag1_x
    var2 = mag2_x
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./smallSignalMag_y]
    type = VectorDiffOrSum
    variable = SSMag_y
    var1 = mag1_y
    var2 = mag2_y
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./smallSignalMag_z]
    type = VectorDiffOrSum
    variable = SSMag_z
    var1 = mag1_z
    var2 = mag2_z
    diffOrSum = 1
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

[]

[Kernels]
  #---------------------------------------#
  #                                       #
  #          Time dependence              #
  #                                       #
  #---------------------------------------#

  [./mag1_x_time]
    type = TimeDerivative
    variable = mag1_x
  [../]
  [./mag1_y_time]
    type = TimeDerivative
    variable = mag1_y
  [../]
  [./mag1_z_time]
    type = TimeDerivative
    variable = mag1_z
  [../]

  [./mag2_x_time]
    type = TimeDerivative
    variable = mag2_x
  [../]
  [./mag2_y_time]
    type = TimeDerivative
    variable = mag2_y
  [../]
  [./mag2_z_time]
    type = TimeDerivative
    variable = mag2_z
  [../]


  #---------------------------------------#
  #                                       #
  #     AFM resonance kernel terms        #
  #                                       #
  #---------------------------------------#

  [./afmr1_x]
    type = UniaxialAFMSublattice
    variable = mag1_x
    mag_sub = 0
    component = 0
  [../]
  [./afmr1_y]
    type = UniaxialAFMSublattice
    variable = mag1_y
    mag_sub = 0
    component = 1
  [../]
  [./afmr1_z]
    type = UniaxialAFMSublattice
    variable = mag1_z
    mag_sub = 0
    component = 2
  [../]


  [./afmr2_x]
    type = UniaxialAFMSublattice
    variable = mag2_x
    mag_sub = 1
    component = 0
  [../]
  [./afmr2_y]
    type = UniaxialAFMSublattice
    variable = mag2_y
    mag_sub = 1
    component = 1
  [../]
  [./afmr2_z]
    type = UniaxialAFMSublattice
    variable = mag2_z
    mag_sub = 1
    component = 2
  [../]

  #---------------------------------------#
  #                                       #
  #          LLB constraint terms         #
  #                                       #
  #---------------------------------------#

  [./llb1_x]
    type = LongitudinalLLB
    variable = mag1_x
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 0
  [../]
  [./llb1_y]
    type = LongitudinalLLB
    variable = mag1_y
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 1
  [../]

  [./llb1_z]
    type = LongitudinalLLB
    variable = mag1_z
    mag_x = mag1_x
    mag_y = mag1_y
    mag_z = mag1_z
    component = 2
  [../]

  [./llb2_x]
    type = LongitudinalLLB
    variable = mag2_x
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 0
  [../]
  [./llb2_y]
    type = LongitudinalLLB
    variable = mag2_y
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 1
  [../]

  [./llb2_z]
    type = LongitudinalLLB
    variable = mag2_z
    mag_x = mag2_x
    mag_y = mag2_y
    mag_z = mag2_z
    component = 2
  [../]
[]

[BCs]
  #---------------------------------------#
  #                                       #
  #  periodic magnetization distribution  #
  #                                       #
  #---------------------------------------#

  [./Periodic]
    [./xyz]
      auto_direction = &#x27;x y z&#x27;
      variable = &#x27;mag1_x mag1_y mag1_z mag2_x mag2_y mag2_z&#x27;
    [../]
  [../]

[]

[Postprocessors]
   [./dt]
     type = TimestepSize
   [../]

  #---------------------------------------#
  #                                       #
  #       Average |M| and along other     #
  #       directions                      #
  #                                       #
  #---------------------------------------#

  [./&lt;M1&gt;]
    type = ElementAverageValue
    variable = mag1_s
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;M2&gt;]
    type = ElementAverageValue
    variable = mag2_s
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]


  [./&lt;m1x&gt;]
    type = ElementAverageValue
    variable = mag1_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m1y&gt;]
    type = ElementAverageValue
    variable = mag1_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m1z&gt;]
    type = ElementAverageValue
    variable = mag1_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;m2x&gt;]
    type = ElementAverageValue
    variable = mag2_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m2y&gt;]
    type = ElementAverageValue
    variable = mag2_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;m2z&gt;]
    type = ElementAverageValue
    variable = mag2_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]


  [./&lt;Lx&gt;]
    type = ElementAverageValue
    variable = Neel_L_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;Ly&gt;]
    type = ElementAverageValue
    variable = Neel_L_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;Lz&gt;]
    type = ElementAverageValue
    variable = Neel_L_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]

  [./&lt;SSmx&gt;]
    type = ElementAverageValue
    variable = SSMag_x
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;SSmy&gt;]
    type = ElementAverageValue
    variable = SSMag_y
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
  [./&lt;SSmz&gt;]
    type = ElementAverageValue
    variable = SSMag_z
    execute_on = &#x27;initial timestep_end final&#x27;
  [../]
[]


[Preconditioning]
  #---------------------------------------#
  #                                       #
  #            Solver options             #
  #                                       #
  #---------------------------------------#

  [./smp]
    type = SMP
    full = true
    petsc_options = &#x27;-snes_ksp_ew&#x27;
    petsc_options_iname = &#x27; -ksp_gmres_restart -snes_atol -snes_rtol -ksp_rtol -pc_type&#x27;
    petsc_options_value = &#x27;    121               1e-8      1e-6      1e-6      bjacobi&#x27;
  [../]
[]

[Executioner]
  type = Transient            
  solve_type = &#x27;NEWTON&#x27;
  [./TimeIntegrator]
    type = ImplicitEuler
  [../]
  dtmin = 1e-11
  dtmax = 1.0e-3
  [./TimeStepper]
    type = IterationAdaptiveDT
    optimal_iterations = 25
    iteration_window = 2000
    growth_factor = 1.3
    cutback_factor = 0.8
    dt = 4.0e-9
  [../]
  verbose = true

  num_steps = 2
[]

[Outputs]
  print_linear_residuals = false
  [./out]
    type = Exodus
    file_base = out_AFMR_ex
    elemental_as_nodal = true
    interval = 1
  [../]
  [./outCSV]
    type = CSV
    file_base = out_AFMR_ex
    interval = 1
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>