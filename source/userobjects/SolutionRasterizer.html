<!DOCTYPE html><head><meta charset="UTF-8"><title>SolutionRasterizer | Ferret</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="2270874f-3fa8-4573-921c-c3b178c7d826" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="27c9cf69-6512-4ee6-a08f-e3cf8b689f9d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="846627ab-aa74-4863-8c45-f21475992a66" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="db1ceffe-68f8-471e-9427-8e9595b80482" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="9105d71a-7b29-4592-aafe-085a764df289" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="75504f0a-53e4-4c0f-892e-c3b53dcf3885"><i class="material-icons">menu</i></a><ul class="sidenav" id="75504f0a-53e4-4c0f-892e-c3b53dcf3885"><li><a href="#!" class="dropdown-trigger" data-target="cff2fe7a-c41d-4277-8474-cbc8bc53c324" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="93c41946-2e74-47f1-993d-b33acc2e1193" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1609ff26-6316-49b7-a1d1-3198b2f8453b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="4a168038-3472-4917-b8c3-bbf7ceece3d3" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="9419cafb-cc59-4ecf-be39-306c3f4f0751" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="2270874f-3fa8-4573-921c-c3b178c7d826"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="27c9cf69-6512-4ee6-a08f-e3cf8b689f9d"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="846627ab-aa74-4863-8c45-f21475992a66"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="db1ceffe-68f8-471e-9427-8e9595b80482"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="9105d71a-7b29-4592-aafe-085a764df289"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="cff2fe7a-c41d-4277-8474-cbc8bc53c324"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="93c41946-2e74-47f1-993d-b33acc2e1193"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="1609ff26-6316-49b7-a1d1-3198b2f8453b"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="4a168038-3472-4917-b8c3-bbf7ceece3d3"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="9419cafb-cc59-4ecf-be39-306c3f4f0751"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="d06ea216-fa52-41a2-97d2-3c3d3d432ee2" data-section-level="1" data-section-text="SolutionRasterizer"><h1 id="solutionrasterizer">SolutionRasterizer</h1><p>Process an XYZ file of atomic coordinates and filter atoms via threshold or map variable values.</p><p>Mesoscale microstructure simulations using the phase field method can be utilized to generate initial structures for large sacle molecular dynamics simulations. One application is the construction of nano-foam atomistic samples from simulations of spinodal decomposition.</p><div class="card moose-float" style="width:30%;padding-left:20px;float:right;"><div class="card-content"><picture class="materialboxed moose-image"><img src="../../media/phase_field/solutionrasterizer.png"></img></picture><p class="moose-caption"><span class="moose-caption-text">Nano foam atomistic configuration generated using the <code>SolutionRasterizer</code>.</span></p></div></div><p>MOOSE provides a built in system to template an atomic coordinate file in the <code>.xyz</code> format from the simulation result in a given mesh file. The workflow is as follows</p><ol class="browser-default" start="1"><li><p>Set up a phase field simulation and output a finite element mesh file </p></li><li><p>Create a bulk <code>.xyz</code> input file with the desired underlying lattice and crystal structure </p></li><li><p>Use the minimal input file shown below to load the mesh and <code>.xyz</code> input</p></li></ol><p>MOOSE will load the <code>.xyz</code> input and finite element mesh superpose both and use thresholding to carve out _rejected_ atoms while retaining _accepted_ atoms. Finally a new <code>.xyz</code> output is written containing only the _accepted_ atoms, generating a porous microstructure.</p><p>The <code>SolutionRasterizer</code> user object is derived from the <a href="/wiki/MooseSystems/UserObjects/SolutionUserObject"><code>SolutionUserObject</code></a> and inherits its input parameters. It takes the following additional input parameters:</p><div form="['center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Input Parameter</th><th style=";text-align:center">Description</th></tr></thead><tbody><tr><td style=";text-align:center">|<code>xyz_input</code></td><td style=";text-align:center">An <code>.xyz</code> file as an input file. This input file should contain an atomistic simulation cell completely filled with atoms of a chosen crystal structure (a polycrystalline sample can be supplied).</td></tr></tbody><tbody><tr><td style=";text-align:center">|<code>xyz_output</code></td><td style=";text-align:center"><em></em>Output file** containing the filtered (or mapped) atomic coordinate file.</td></tr></tbody><tbody><tr><td style=";text-align:center"><code>raster_mode = FILTER</code></td><td style=";text-align:center">In <code>FILTER</code> mode the <code>SolutionRasterizer</code> uses thresholding on a specified non-linear variable to reject or accept atom from the input file to pass to the output <code>.xyz</code> file.|</td></tr></tbody><tbody><tr><td style=";text-align:center"><code>raster_mode = MAP</code></td><td style=";text-align:center">In <code>MAP</code> mode the <code>SolutionRasterizer</code> takes the atoms from the input file and add an additional column to the data set containing the value of a specified non-linear variable.|</td></tr></tbody><tbody><tr><td style=";text-align:center"><code>threshold</code></td><td style=";text-align:center">Value of the selected non-linear variable to use in <code>FILTER</code> mode used to _accept_ or _reject_ atoms from the <code>xyz_input</code> file.|</td></tr></tbody></table></div><section id="d96aa448-1afe-444c-b3cd-8cf953bc6e6c" data-section-level="3" data-section-text="Minimal working input file"><h3 id="minimal-working-input-file">Minimal working input file</h3><p>The following input can be executed with the MOOSE Phase Field module executable and will</p><ul class="browser-default"><li><p>load the mesh file <code>diffuse_out.e</code> </p></li><li><p>load the atomic coordinate file <code>in.xyz</code> </p></li><li><p>accept all atoms at the coordinates where the value of the non-linear variable <code>c</code> is above a value of <code>0.5</code> </p></li><li><p>write out the atomic coordinate file <code>out.xyz</code></p></li></ul><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
[]

[Problem]
  kernel_coverage_check = false
  solve = false
[]

[Executioner]
  type = Steady
[]

[UserObjects]
  [./soln]
    type = SolutionRasterizer
    system_variables = &#x27;c&#x27;
    mesh = diffuse_out.e
    execute_on = timestep_begin

    variable = c
    xyz_input = in.xyz
    xyz_output = out.xyz

    # raster_mode = MAP
    raster_mode = FILTER
    threshold = 0.5
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8c8741e8-486b-4ecb-8d63-4a6cdce04b9e">(../moose/modules/phase_field/test/tests/solution_rasterizer/raster.i)</a></section></section><section id="f176770b-9e09-43ca-a076-4473d9e652b4" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="34cf8757-7273-4767-9b38-279b37946f97" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">mesh</span><span class="moose-parameter-header-description">The name of the mesh file (must be xda/xdr or exodusII file).</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MeshFileName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the mesh file (must be xda/xdr or exodusII file).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">Variable from the mesh file to use for mapping to or filtering of the atoms.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Variable from the mesh file to use for mapping to or filtering of the atoms.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">xyz_input</span><span class="moose-parameter-header-description">XYZ input file.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>XYZ input file.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">xyz_output</span><span class="moose-parameter-header-description">XYZ output file.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>XYZ output file.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="8608628f-7b6a-47e7-8073-7eda0edcf6d2" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">es</span><span class="moose-parameter-header-default"><not supplied></span><span class="moose-parameter-header-description">The name of the file holding the equation system info in xda/xdr format (xda/xdr only).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span><not supplied></p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>FileName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the file holding the equation system info in xda/xdr format (xda/xdr only).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">execute_on</span><span class="moose-parameter-header-default">TIMESTEP_END</span><span class="moose-parameter-header-description">The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, MULTIAPP_FIXED_POINT_END, MULTIAPP_FIXED_POINT_BEGIN, FINAL, CUSTOM, ALWAYS.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>TIMESTEP_END</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>ExecFlagEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, MULTIAPP_FIXED_POINT_END, MULTIAPP_FIXED_POINT_BEGIN, FINAL, CUSTOM, ALWAYS</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of flag(s) indicating when this object should be executed, the available options include NONE, INITIAL, LINEAR, NONLINEAR, TIMESTEP_END, TIMESTEP_BEGIN, MULTIAPP_FIXED_POINT_END, MULTIAPP_FIXED_POINT_BEGIN, FINAL, CUSTOM, ALWAYS.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">raster_mode</span><span class="moose-parameter-header-default">MAP</span><span class="moose-parameter-header-description">Rasterization mode (MAP|FILTER).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>MAP</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>MAP, FILTER</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Rasterization mode (MAP|FILTER).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation1_vector</span><span class="moose-parameter-header-default">0 0 1</span><span class="moose-parameter-header-description">Vector about which to rotate points of the simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>libMesh::VectorValue&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector about which to rotate points of the simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">system</span><span class="moose-parameter-header-default">nl0</span><span class="moose-parameter-header-description">The name of the system to pull values out of (xda/xdr only). The default name for the nonlinear system is 'nl0', auxiliary system is 'aux0'</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nl0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the system to pull values out of (xda/xdr only). The default name for the nonlinear system is 'nl0', auxiliary system is 'aux0'</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">system_variables</span><span class="moose-parameter-header-description">The name of the nodal and elemental variables from the file you want to use for values</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the nodal and elemental variables from the file you want to use for values</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">threshold</span><span class="moose-parameter-header-description">Accept atoms with a variable value above this threshold in FILTER mode.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Accept atoms with a variable value above this threshold in FILTER mode.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">timestep</span><span class="moose-parameter-header-description">Index of the single timestep used or "LATEST" for the last timestep (exodusII only).  If not supplied, time interpolation will occur.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::string</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Index of the single timestep used or "LATEST" for the last timestep (exodusII only).  If not supplied, time interpolation will occur.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="3bce6c09-7dcc-4576-befa-c43db2fbb436" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">allow_duplicate_execution_on_initial</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>In the case where this UserObject is depended upon by an initial condition, allow it to be executed twice during the initial setup (once before the IC and again after mesh adaptivity (if applicable).</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">execution_order_group</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Execution order groups are executed in increasing order (e.g., the lowest number is executed first). Note that negative group numbers may be used to execute groups before the default (0) group. Please refer to the user object documentation for ordering of user object execution within a group.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Execution order groups are executed in increasing order (e.g., the lowest number is executed first). Note that negative group numbers may be used to execute groups before the default (0) group. Please refer to the user object documentation for ordering of user object execution within a group.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_postaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the UserObject to be executed in POSTAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Forces the UserObject to be executed in POSTAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preaux</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the UserObject to be executed in PREAUX</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Forces the UserObject to be executed in PREAUX</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">force_preic</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Forces the UserObject to be executed in PREIC during initial setup</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Forces the UserObject to be executed in PREIC during initial setup</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="da1c2dcf-b4a0-415a-bcda-4c2cede2a09a" data-section-level="3" data-section-text="Coordinate System Transformation Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">rotation0_angle</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Anticlockwise rotation angle (in degrees) to use for rotation about rotation0_vector.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Anticlockwise rotation angle (in degrees) to use for rotation about rotation0_vector.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation0_vector</span><span class="moose-parameter-header-default">0 0 1</span><span class="moose-parameter-header-description">Vector about which to rotate points of the simulation.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 1</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>libMesh::VectorValue&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector about which to rotate points of the simulation.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">rotation1_angle</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">Anticlockwise rotation angle (in degrees) to use for rotation about rotation1_vector.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Anticlockwise rotation angle (in degrees) to use for rotation about rotation1_vector.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale</span><span class="moose-parameter-header-default">1 1 1 </span><span class="moose-parameter-header-description">Scale factor for points in the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1 1 1 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Scale factor for points in the simulation</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">scale_multiplier</span><span class="moose-parameter-header-default">1 1 1 </span><span class="moose-parameter-header-description">Scale multiplying factor for points in the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>1 1 1 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Scale multiplying factor for points in the simulation</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">transformation_order</span><span class="moose-parameter-header-default">translation scale</span><span class="moose-parameter-header-description">The order to perform the operations in.  Define R0 to be the rotation matrix encoded by rotation0_vector and rotation0_angle.  Similarly for R1.  Denote the scale by s, the scale_multiplier by m, and the translation by t.  Then, given a point x in the simulation, if transformation_order = 'rotation0 scale_multiplier translation scale rotation1' then form p = R1*(R0*x*m - t)/s.  Then the values provided by the SolutionUserObject at point x in the simulation are the variable values at point p in the mesh.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>translation scale</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>rotation0, translation, scale, rotation1, scale_multiplier</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The order to perform the operations in.  Define R0 to be the rotation matrix encoded by rotation0_vector and rotation0_angle.  Similarly for R1.  Denote the scale by s, the scale_multiplier by m, and the translation by t.  Then, given a point x in the simulation, if transformation_order = 'rotation0 scale_multiplier translation scale rotation1' then form p = R1*(R0*x*m - t)/s.  Then the values provided by the SolutionUserObject at point x in the simulation are the variable values at point p in the mesh.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">translation</span><span class="moose-parameter-header-default">0 0 0 </span><span class="moose-parameter-header-description">Translation factors for x,y,z coordinates of the simulation</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0 0 0 </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;double&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Translation factors for x,y,z coordinates of the simulation</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Coordinate System Transformation Parameters</h3></summary></details></section></section><div class="moose-modal modal" id="8c8741e8-486b-4ecb-8d63-4a6cdce04b9e"><div class="modal-content"><h4>(../moose/modules/phase_field/test/tests/solution_rasterizer/raster.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 3
[]

[Problem]
  kernel_coverage_check = false
  solve = false
[]

[Executioner]
  type = Steady
[]

[UserObjects]
  [./soln]
    type = SolutionRasterizer
    system_variables = &#x27;c&#x27;
    mesh = diffuse_out.e
    execute_on = timestep_begin

    variable = c
    xyz_input = in.xyz
    xyz_output = out.xyz

    # raster_mode = MAP
    raster_mode = FILTER
    threshold = 0.5
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>