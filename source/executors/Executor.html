<!DOCTYPE html><head><meta charset="UTF-8"><title>Executor | Ferret</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Ferret</a><a href="https://github.com/mangerij/ferret" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="ebf72995-7d7e-4a0a-bd1e-1d2db670d209" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="38138c5c-3058-4931-b298-8c02f1414bec" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8d359d42-4b21-4c1d-87a8-90a4478c9d5f" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b4c98861-ba8f-4bf5-8f9e-740638c55792" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="251746e1-a383-47cb-9612-0ad90fb32846" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#" class="sidenav-trigger" data-target="f8793932-ebe2-4be3-9da0-289d8f33b809"><i class="material-icons">menu</i></a><ul class="sidenav" id="f8793932-ebe2-4be3-9da0-289d8f33b809"><li><a href="#!" class="dropdown-trigger" data-target="c80a4edc-4de7-401e-813f-ad03e9997c1b" data-constrainWidth="false">Get Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1d736245-8257-4dec-8e85-3e8befaafcc4" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d82f1037-a420-462b-8c8a-4070df1b8383" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1715a4fe-afc3-4238-9d19-675a15687916" data-constrainWidth="false">EU Horizon2020-IF<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../publication_highlights/publication_highlights.html">Highlights</a></li><li><a href="#!" class="dropdown-trigger" data-target="9f58a99b-f7e0-4b2d-9bc2-78e065a4cbd4" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contact</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="ebf72995-7d7e-4a0a-bd1e-1d2db670d209"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="38138c5c-3058-4931-b298-8c02f1414bec"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="8d359d42-4b21-4c1d-87a8-90a4478c9d5f"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="b4c98861-ba8f-4bf5-8f9e-740638c55792"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="251746e1-a383-47cb-9612-0ad90fb32846"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul><ul class="dropdown-content" id="c80a4edc-4de7-401e-813f-ad03e9997c1b"><li><a href="../../getting_started/install.html">Install FERRET</a></li><li><a href="../../getting_started/update.html">Update FERRET</a></li><li><a href="../../getting_started/running.html">Running FERRET</a></li><li><a href="../../getting_started/paraview.html">Visualization Tools</a></li><li><a href="../../getting_started/docs.html">Browse the documentation locally</a></li></ul><ul class="dropdown-content" id="1d736245-8257-4dec-8e85-3e8befaafcc4"><li><a href="../../theory/intro_LGD.html">Phase Field Method of Ferroelectricity (FE)</a></li><li><a href="../../theory/intro_LLG.html">Micromagnetic Simulations</a></li><li><a href="../../theory/intro_piezo.html">Piezoelectricity</a></li><li><a href="../../theory/intro_thermo.html">Thermoelectric Phenomena</a></li><li><a href="../../theory/intro_optical.html">Optical Properties</a></li></ul><ul class="dropdown-content" id="d82f1037-a420-462b-8c8a-4070df1b8383"><li><a href="../../tutorials/FE_phase_field_multi_domain.html">Multidomain ferroelectric</a></li><li><a href="../../tutorials/ferroelectric_domain_wall.html">Ferroelectric domain wall</a></li><li><a href="../../tutorials/FE_phase_field_multi_domain_coupled.html">Ferroelectric thin film</a></li><li><a href="../../tutorials/magnetic_ringdown.html">Magnetic ringdown</a></li><li><a href="../../tutorials/AFM_dynamics.html">Antiferromagnetic dynamics</a></li><li><a href="../../tutorials/piezoelectric.html">Piezoelectric actuation</a></li><li><a href="../../tutorials/thermoelectric.html">Polycrystalline thermoelectric transport</a></li></ul><ul class="dropdown-content" id="1715a4fe-afc3-4238-9d19-675a15687916"><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results1.html">Background and model</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_results2.html">Summary of key results</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex1.html">Example (ground states)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex2.html">Example (FE DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex3.html">Example (magnetic DWs)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex4.html">Example (ME switching)</a></li><li><a href="../../MSCA_EU_Horizon2020_Results/horizon2020_ex5.html">Example (spin wave transport)</a></li></ul><ul class="dropdown-content" id="9f58a99b-f7e0-4b2d-9bc2-78e065a4cbd4"><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/ferret_only_syntax.html">FERRET syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="gcse-search"></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="db13e875-948d-498a-b941-0b2e2c424f14" data-section-level="1" data-section-text="Executor"><h1 id="executor">Executor</h1><p>The Executor controls the &quot;execution&quot; behavior of the simulation. They direct the flow of solves, stepping, output recording, etc.  Executors are similar to the original Executioner system in that they have one primary virtual function that each executor implements that defines its behavior.  However, executors differ in that they are designed to be composed into arbitrary tree structures both in-code and by users via input files - similar to how the MeshGenerator system works.  The Executor system is currently highly experimental and has not yet stabilized and been fully implemented.  For this reason, MOOSE will only run in this mode if given the <code>--executor</code> flag on the command line.  The system name may change, input syntax may change, etc.  YOU WERE WARNED!</p><section id="9ce08c2c-430a-471c-ae14-5174cf48fbd7" data-section-level="2" data-section-text="Using Executors from input files"><h2 id="using-executors-from-input-files">Using Executors from input files</h2><p>When using executors, you must remember to pass in the <code>--executor</code> flag on the cli when you run your application binary.  This allows the Executioner block to be omitted and causes MOOSE to ignore it if present.  Support for a new <code>[Executor]</code> block has been added to input files.  Users will populate this block with equivalent content that normally was present in the <code>[Executioner]</code> block. A hypothetical example is this:</p><pre class="moose-pre"><code class="language-text">
[Executor]
  [solve]
    type = FooSolver
    max_its = 42
    ...
  []
  [refine]
    type = Refine
    inner = solve
  []
  [init]
    type = Init
    inner = refine
    petsc_options = ...
  []
[]
</code></pre><p>Which might perform the equivalent of something like the current <code>Steady</code> executioner.  In this example, &quot;init&quot; becomes the primary executor which does some things to set up and tear down the simulation.  Inside its setup and tear-down, it executes an inner executor that has been set to &quot;refine&quot;.  The &quot;refine&quot; executor does some mesh refinement things and then executes an inner executor - which here has been set to &quot;solve&quot;. This allows refinement to be wrapped/inserted into arbitrary areas of the simulation execution process.</p><p>The new system, is also capable of providing alias-like executors that generate equivalent executor trees programmatically in order to replicate the current <code>Steady</code> or <code>Transient</code> behavior like users currently expect now:</p><pre class="moose-pre"><code class="language-text">
[Executor]
  [steady]
    type = FauxSteady
    solve_type = &#x27;PJFNK&#x27;
    petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
    petsc_options_value = &#x27;hypre boomeramg&#x27;
    ...
  []
[]
</code></pre><p>This executor would simply generate the init+solve+refine trio of executors programmatically - hiding the executor structure from the user.  By default the last executor listed in the <code>Executor</code> block becomes the master/primary executor. MOOSE only directly executes this executor; all other executors are executed if/when execution reaches them within the executor tree starting from the master executor.</p><p>By default, an executor has automatically generated execute-on flags created for it.  These flags are executed right before and right after the executor executes and are named <code>exec_[obj-name]_begin</code> and <code>exec_[obj-name]_end</code> respectively where <code>[obj-name]</code> is the name given to an object by its block header in an input file - e.g. <code>[foo] type = FooExecutor []</code> has an object name of <code>foo</code>. Other objects (e.g. user objects, materials, etc.) can be assigned to execute at these execute-on flags/times within the input file.  This behavior is NOT fully implemented and will almost certainly not work right - so you should definitely not try to use it (yet).  The names of these flags can also be modified from within the input file via an executor&#x27;s <code>begin_exec_flag</code> and <code>end_exec_flag</code> input parameters.</p></section><section id="dad8abec-d8df-4c26-934f-9c3fa9b8878c" data-section-level="2" data-section-text="Writing Custom Executors"><h2 id="writing-custom-executors">Writing Custom Executors</h2><p>Executors have one primary function - <code>virtual Result run()</code> that must be implemented.  If an executor has any internal executors, it will call these executors&#x27; <code>Result exec()</code> functions - NOT their run functions.</p><p>All executors&#x27; &quot;exec&quot; and &quot;run&quot; functions return a <code>Result</code> value containing information about how execution turned out within the executor tree.  Each executor is responsible for recording how convergence/success occurs within it. This should generally be accomplished using the <code>Result::pass(msg)</code> and <code>Result::fail(msg)</code> functions on a result object created and initialized by calling the <code>newResult()</code> member function:</p><pre class="moose-pre"><code class="language-text">
Result
FooExecutor::run()
{
  Result &amp; r = newResult(); // MUST catch this return value by reference

  ...
  bool success = ... // do some solve stuff

  if (!success)
    r.fail(&quot;the foo didn&#x27;t work right with the bar&quot;);
  else
  {
    // by default, a result is considered successful/converged - so we only need
    // to call fail on failure - and calling pass on success is optional.
    r.pass(&quot;runnin&#x27; like a well oiled machine&quot;);
  }

  ...

  return r;
}
</code></pre><p>Some executors will have internal/sub executors that they need to execute.  They are both responsible for initiating this execution as well as recording the result value generated by these executors using the <code>Result::record</code> function:</p><pre class="moose-pre"><code class="language-text">

InputParameters
Steady2::validParams()
{
  InputParameters params = Executor::validParams();
  // create input parameters for our sub/internal solve executors
  params.addRequiredParam&lt;std::string&gt;(&quot;solve1&quot;, &quot;the first solve&quot;);
  params.addRequiredParam&lt;std::string&gt;(&quot;solve2&quot;, &quot;the second solve&quot;);
  return params;
}

FooExecutor::FooExecutor(InputParameters &amp; params)
  : _inner_solve1(&amp;_fe_problem.getExecutor(getParam&lt;std::string&gt;(&quot;solve1&quot;))), // retrieve inner executor objects
    _inner_solve2(&amp;_fe_problem.getExecutor(getParam&lt;std::string&gt;(&quot;solve2&quot;)))
{
}

Result
FooExecutor::run()
{
  Result &amp; r = newResult();
  ...
  // When we record an inner/sub executor&#x27;s result, we give it a label - which
  // helps identify its placement/role within the executor heirarchy.
  r.record(&quot;solve1&quot;, _inner_solve1-&gt;exec());
  r.record(&quot;solve2&quot;, _inner_solve2-&gt;exec());
  ...
  return r;
}
</code></pre><p>Result values provide a convenience <code>bool convergedAll()</code>function for recursively determining if <em>any</em> single executor result within the currently executed portion of the tree has failed to converge.  When checking for convergence within an executor, this is usually the mechanism that should be used:</p><pre class="moose-pre"><code class="language-text">
Result
FooExecutor::run()
{
  Result &amp; r = newResult();
  ...
  // When we record an inner/sub executor&#x27;s result, we give it a label - which
  // helps identify its placement/role within the executor heirarchy.
  r.record(&quot;solve1&quot;, _inner_solve1-&gt;exec());
  r.record(&quot;solve2&quot;, _inner_solve2-&gt;exec());

  // something inside _inner_solve1 or _inner_solve2 may have failed to converge
  if (!r.convergedAll())
  {
    r.fail(&quot;foo iterations didn&#x27;t work right&quot;); // maybe add additional error msg context
    return r; // maybe you want to bail early
  }

  r.record(&quot;solve3&quot;, _inner_solve3-&gt;exec());
  ...
  return r;
}
</code></pre></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="https://cse.google.com/cse.js?cx=008852834041008754713:g3ilnhhbbj9"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>